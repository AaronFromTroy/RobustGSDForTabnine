---
phase: 02-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - gsd/scripts/file-ops.js
  - gsd/scripts/process-runner.js
autonomous: true

must_haves:
  truths:
    - "Scripts can read and write files atomically"
    - "Scripts can execute child processes safely"
    - "File operations work cross-platform (Windows, macOS, Linux)"
  artifacts:
    - path: "gsd/scripts/file-ops.js"
      provides: "File read/write utilities with atomic writes"
      exports: ["readFile", "writeFileAtomic", "fileExists"]
      min_lines: 40
    - path: "gsd/scripts/process-runner.js"
      provides: "Safe child process execution wrapper"
      exports: ["runCommand"]
      min_lines: 30
  key_links:
    - from: "file-ops.js"
      to: "write-file-atomic"
      via: "import statement"
      pattern: "import.*write-file-atomic"
    - from: "process-runner.js"
      to: "node:child_process"
      via: "spawn function"
      pattern: "spawn\\("
---

<objective>
Create foundational utility modules for atomic file operations and safe child process execution, establishing the core primitives that all higher-level scripts will use.

Purpose: Implement the patterns from RESEARCH.md (atomic writes with write-file-atomic, safe spawn() usage, cross-platform paths) as reusable modules. These utilities prevent common pitfalls (corrupted STATE.md, shell injection, Windows path failures).

Output: Two tested utility modules providing file I/O and command execution capabilities.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.planning\phases\02-core-infrastructure\02-RESEARCH.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\gsd\package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file-ops.js with atomic write utilities</name>
  <files>gsd/scripts/file-ops.js</files>
  <action>
Create gsd/scripts/file-ops.js as an ESM module with the following exports:

**Import dependencies:**
```javascript
import { readFile as fsReadFile, access, mkdir } from 'node:fs/promises';
import { writeFile } from 'write-file-atomic';
import path from 'node:path';
```

**Export async function readFile(filePath):**
- Use fs.promises.readFile() with utf8 encoding
- Wrap in try/catch
- If error.code === 'ENOENT', throw clear error: `File not found: ${filePath}`
- For other errors, throw: `Failed to read ${filePath}: ${error.message}`
- Return file contents as string

**Export async function writeFileAtomic(filePath, content):**
- Use write-file-atomic's writeFile() function (NOT fs.writeFile - not atomic per RESEARCH.md)
- Write with utf8 encoding
- Atomic write uses temp-file-then-rename pattern (handles interruptions)
- Wrap in try/catch with clear error: `Failed to write ${filePath}: ${error.message}`
- Return nothing (void)

**Export async function fileExists(filePath):**
- Use fs.promises.access() to check file existence
- Return true if file exists, false if ENOENT error
- Rethrow other errors (permission denied, etc.)

**Export async function ensureDir(dirPath):**
- Use fs.promises.mkdir() with { recursive: true }
- Create parent directories if needed
- No error if directory already exists

**Critical patterns from RESEARCH.md:**
- Use node: protocol for built-in imports (node:fs/promises, node:path)
- Use path.join() for all path construction (never hardcode / or \\)
- All functions async (no *Sync methods - blocks event loop)
- Named exports (not default export)
- Mandatory .js extension when importing this module elsewhere

**Anti-patterns to avoid:**
- fs.writeFileSync() - blocks event loop
- fs.writeFile() - NOT atomic, can corrupt files
- Hardcoded path separators
- Missing error context in thrown errors
  </action>
  <verify>
```bash
cd C:/Projects/GSDForTabnine
node --input-type=module -e "
import { readFile, writeFileAtomic, fileExists } from './gsd/scripts/file-ops.js';
await writeFileAtomic('.test-atomic.txt', 'test content');
const content = await readFile('.test-atomic.txt');
const exists = await fileExists('.test-atomic.txt');
console.log('Write success:', content === 'test content');
console.log('Exists check:', exists === true);
"
rm .test-atomic.txt
```

Expected: Both checks print true, test file created and cleaned up.
  </verify>
  <done>file-ops.js exports readFile, writeFileAtomic, fileExists, ensureDir functions; uses write-file-atomic for atomic writes; all functions async</done>
</task>

<task type="auto">
  <name>Task 2: Create process-runner.js for safe command execution</name>
  <files>gsd/scripts/process-runner.js</files>
  <action>
Create gsd/scripts/process-runner.js as an ESM module with safe child process execution:

**Import dependencies:**
```javascript
import { spawn } from 'node:child_process';
```

**Export async function runCommand(command, args = [], options = {}):**

Implements the safe spawn() pattern from RESEARCH.md:

1. **Create child process:**
   - Use spawn(command, args, options) - NOT exec() (shell injection risk)
   - Default stdio: ['ignore', 'pipe', 'pipe'] (ignore stdin, capture stdout/stderr)
   - Merge user options with defaults

2. **Accumulate output:**
   - Create stdout, stderr string accumulators
   - Listen to proc.stdout.on('data') - append to stdout accumulator
   - Listen to proc.stderr.on('data') - append to stderr accumulator
   - Convert Buffer to string with .toString()

3. **Handle errors (CRITICAL - must attach before 'close'):**
   - proc.on('error') fires if process fails to start (command not found)
   - Reject promise with: `Failed to start ${command}: ${err.message}`

4. **Handle completion:**
   - proc.on('close', (code, signal))
   - If signal exists: reject with `${command} killed by signal ${signal}`
   - If code !== 0: reject with `${command} failed with code ${code}\nstderr: ${stderr}`
   - If code === 0: resolve with { stdout: stdout.trim(), stderr: stderr.trim(), code }

5. **Return promise:**
   - Wrap entire function in new Promise((resolve, reject))
   - Promise resolves on successful exit (code 0)
   - Promise rejects on failure or error

**Why spawn() not exec() (from RESEARCH.md):**
- exec() spawns shell, interprets metacharacters - security risk with user input
- exec() buffers entire output in memory - fails with large outputs
- spawn() takes arguments as array - automatically escaped, no injection
- spawn() streams output - handles large outputs gracefully

**Usage examples (in comments):**
```javascript
// await runCommand('git', ['add', '.planning/STATE.md']);
// await runCommand('npm', ['install', 'packageName']);
// const { stdout } = await runCommand('git', ['rev-parse', 'HEAD']);
```

**Anti-patterns to avoid:**
- exec() with string concatenation
- Missing 'error' event handler (causes unhandled errors)
- Not converting Buffer to string (outputs are Buffers)
  </action>
  <verify>
```bash
cd C:/Projects/GSDForTabnine
node --input-type=module -e "
import { runCommand } from './gsd/scripts/process-runner.js';
const result = await runCommand('node', ['--version']);
console.log('Node version check:', result.stdout.startsWith('v'));
console.log('Exit code:', result.code === 0);
"
```

Expected: Both checks print true, shows Node version.
  </verify>
  <done>process-runner.js exports runCommand function using spawn() with proper error handling; streams output; no shell spawning</done>
</task>

</tasks>

<verification>
1. file-ops.js uses write-file-atomic (not fs.writeFile)
2. file-ops.js uses async functions exclusively (no *Sync methods)
3. process-runner.js uses spawn() (not exec())
4. process-runner.js attaches 'error' handler before 'close'
5. Both modules use ESM syntax (import/export)
6. Both modules use node: protocol for built-ins
7. Cross-platform path handling in file-ops.js
</verification>

<success_criteria>
- file-ops.js atomic writes work without file corruption
- process-runner.js executes commands safely without shell injection risk
- Both modules importable in other scripts
- Manual test verification passes for both modules
- Requirements CORE-05 (file operations) and CORE-06 (command execution) partially fulfilled
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-02-SUMMARY.md` documenting:
- file-ops.js functions and atomic write implementation
- process-runner.js spawn() wrapper and error handling
- Test results showing successful import and execution
- Anti-patterns avoided (exec(), synchronous fs, hardcoded paths)
- Requirements fulfilled: CORE-05 (file ops), CORE-06 (command execution), SCRIPT-04 (cross-platform)
</output>
