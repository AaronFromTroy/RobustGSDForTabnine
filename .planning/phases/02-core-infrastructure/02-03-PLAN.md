---
phase: 02-core-infrastructure
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - gsd/scripts/state-manager.js
autonomous: true

must_haves:
  truths:
    - "System can read STATE.md and parse workflow state"
    - "System can write STATE.md atomically without corruption"
    - "STATE.md includes visual progress indicator"
    - "State updates track phase, step, and status transitions"
  artifacts:
    - path: "gsd/scripts/state-manager.js"
      provides: "STATE.md read/write with progress tracking"
      exports: ["readState", "writeState", "updateProgress"]
      min_lines: 60
  key_links:
    - from: "state-manager.js"
      to: "gsd/scripts/file-ops.js"
      via: "import and function calls"
      pattern: "import.*file-ops.*readFile|writeFileAtomic"
    - from: "updateProgress"
      to: "STATE.md progress indicator"
      via: "string manipulation"
      pattern: "█|░"
---

<objective>
Implement atomic STATE.md persistence and progress tracking, enabling the system to maintain workflow state across sessions and display visual progress indicators.

Purpose: Fulfill CORE-02 (state persistence), PROG-01 through PROG-05 (progress tracking), and SCRIPT-01 (state manager implementation). This module is critical for auto-resume capability in Phase 3.

Output: State management module that prevents corrupted STATE.md files and provides progress visualization.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.planning\phases\02-core-infrastructure\02-RESEARCH.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\gsd\scripts\file-ops.js
@C:\Projects\GSDForTabnine\gsd\templates\STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state-manager.js with read/write functions</name>
  <files>gsd/scripts/state-manager.js</files>
  <action>
Create gsd/scripts/state-manager.js as an ESM module for STATE.md operations:

**Import dependencies:**
```javascript
import { readFile, writeFileAtomic } from './file-ops.js';
import path from 'node:path';
```

**Export async function readState(projectRoot):**

1. Construct path: `path.join(projectRoot, '.planning', 'STATE.md')`
2. Read file using file-ops.js readFile()
3. Parse STATE.md content:
   - Extract current phase (regex: /\*\*Phase:\*\* (\d+)/)
   - Extract current plan (regex: /\*\*Plan:\*\* (\d+)/)
   - Extract status (regex: /\*\*Status:\*\* (\w+)/)
   - Extract current step (regex: /\*\*Step:\*\* (.+)/)
   - Extract progress indicator (regex: /\*\*Progress:\*\* `([█░]+)`/)
4. Return state object:
   ```javascript
   {
     phase: Number,
     plan: Number,
     status: String, // 'pending', 'in_progress', 'completed', 'blocked'
     step: String,
     progressIndicator: String,
     lastUpdated: String,
     rawContent: String // full STATE.md for template-based updates
   }
   ```
5. If parsing fails, throw clear error with details

**Export async function writeState(projectRoot, stateData):**

1. Construct path: `path.join(projectRoot, '.planning', 'STATE.md')`
2. Read current STATE.md content
3. Update specific fields using regex replacement:
   - `**Phase:** ${stateData.phase}`
   - `**Plan:** ${stateData.plan}`
   - `**Status:** ${stateData.status}`
   - `**Step:** ${stateData.step}`
   - `**Progress:** \`${stateData.progressIndicator}\``
   - `**Last Updated:** ${new Date().toISOString().split('T')[0]}` (YYYY-MM-DD format)
4. Use file-ops.js writeFileAtomic() for atomic write
5. If write fails, preserve original file (atomic write handles this automatically)

**Export function generateProgressIndicator(currentPhase, totalPhases):**

Generates visual progress bar for STATE.md display:

1. Calculate percentage: `(currentPhase / totalPhases) * 100`
2. Create filled blocks: `'█'.repeat(currentPhase)`
3. Create empty blocks: `'░'.repeat(totalPhases - currentPhase)`
4. Return combined string: `${filled}${empty}` with percentage comment
5. Example: Phase 2 of 4 → `██░░` (50%)

**Export async function updateProgress(projectRoot, updates):**

Convenience function for common state updates:

1. Read current state using readState()
2. Merge updates into current state: `{ ...currentState, ...updates }`
3. If phase changed, regenerate progress indicator
4. Write updated state using writeState()
5. Return updated state object

**Error handling:**
- Wrap all fs operations in try/catch
- Provide context: "Failed to read STATE.md", "Failed to write STATE.md"
- Rethrow with original error message

**Critical from RESEARCH.md:**
- Use writeFileAtomic() from file-ops.js (which uses write-file-atomic library)
- Never use fs.writeFile() directly - NOT atomic, corrupts on interruption
- Use path.join() for all path construction (cross-platform)
  </action>
  <verify>
```bash
cd C:/Projects/GSDForTabnine
node --input-type=module -e "
import { readState, writeState, generateProgressIndicator, updateProgress } from './gsd/scripts/state-manager.js';

// Test progress indicator
const progress = generateProgressIndicator(2, 4);
console.log('Progress indicator:', progress);

// Test read current state
const state = await readState('.');
console.log('Current phase:', state.phase);
console.log('Current status:', state.status);

// Test update (dry run - don't actually modify)
console.log('State manager functions loaded successfully');
"
```

Expected: Progress indicator shows `██░░`, current state displays correctly, no errors.
  </verify>
  <done>state-manager.js exports readState, writeState, generateProgressIndicator, updateProgress functions; uses atomic writes; parses and updates STATE.md fields correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add progress tracking field mappings</name>
  <files>gsd/scripts/state-manager.js</files>
  <action>
Extend state-manager.js with field mapping constants and validation:

**Add constant STATUS_VALUES:**
```javascript
export const STATUS_VALUES = {
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  COMPLETED: 'completed',
  BLOCKED: 'blocked'
};
```

**Add function validateStateData(stateData):**

Validates state object before writing:

1. Check required fields exist: phase, plan, status, step
2. Check status is one of STATUS_VALUES
3. Check phase and plan are positive integers
4. Check step is non-empty string
5. Throw descriptive error if validation fails:
   - "Missing required field: {field}"
   - "Invalid status: {status}. Must be one of: {validStatuses}"
   - "Phase and plan must be positive integers"

**Update writeState() to call validateStateData():**
- Call validateStateData(stateData) before any file operations
- Validation failure throws error before touching STATE.md
- Prevents writing invalid state that breaks auto-resume

**Add convenience function transitionPhase(projectRoot, newPhase, totalPhases):**

Specialized function for phase transitions (used by orchestration in Phase 3):

1. Read current state
2. Create updated state:
   - phase: newPhase
   - plan: 0 (reset plan counter)
   - status: STATUS_VALUES.IN_PROGRESS
   - step: `Ready for Phase ${newPhase}`
   - progressIndicator: generateProgressIndicator(newPhase, totalPhases)
3. Validate and write state
4. Return updated state

**Update all regex patterns to handle optional whitespace:**
- `/\*\*Phase:\*\*\s*(\d+)/` (handles extra spaces)
- `/\*\*Status:\*\*\s*(\w+)/`
- Similar for all field extractions

This prevents parsing failures on manual STATE.md edits with formatting variations.
  </action>
  <verify>
```bash
cd C:/Projects/GSDForTabnine
node --input-type=module -e "
import { STATUS_VALUES, validateStateData, transitionPhase } from './gsd/scripts/state-manager.js';

// Test validation
try {
  validateStateData({ phase: 2, plan: 1, status: 'invalid', step: 'test' });
  console.log('ERROR: Should have thrown validation error');
} catch (err) {
  console.log('Validation correctly rejected invalid status');
}

// Test valid state
validateStateData({ phase: 2, plan: 1, status: STATUS_VALUES.IN_PROGRESS, step: 'test' });
console.log('Validation passed for valid state');

console.log('All state manager functions working');
"
```

Expected: Invalid status rejected, valid state accepted, no errors on valid input.
  </verify>
  <done>state-manager.js includes STATUS_VALUES, validateStateData, transitionPhase functions; validates before writing; handles whitespace in parsing</done>
</task>

</tasks>

<verification>
1. state-manager.js uses file-ops.js for all file operations
2. writeState uses writeFileAtomic (atomic writes)
3. readState parses all required STATE.md fields
4. generateProgressIndicator produces correct visual bars
5. validateStateData rejects invalid states
6. All regex patterns handle whitespace variations
7. Manual test successfully reads current STATE.md
</verification>

<success_criteria>
- state-manager.js can read and parse existing STATE.md
- writeState performs atomic updates without corruption
- Progress indicator generates correctly (e.g., ██░░ for 2/4 phases)
- State validation prevents invalid data from being written
- Requirements CORE-02 (state persistence), PROG-01 through PROG-05 (progress tracking), SCRIPT-01 (state manager) fulfilled
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-03-SUMMARY.md` documenting:
- state-manager.js functions and atomic write usage
- STATE.md field parsing and update logic
- Progress indicator generation examples
- Validation rules and error handling
- Test results showing successful read/write operations
- Requirements fulfilled: CORE-02, PROG-01, PROG-02, PROG-03, PROG-04, PROG-05, SCRIPT-01
</output>
