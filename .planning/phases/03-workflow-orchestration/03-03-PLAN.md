---
phase: 03-workflow-orchestration
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - gsd/scripts/resume-manager.js
  - gsd/scripts/workflow-orchestrator.js
autonomous: true

must_haves:
  truths:
    - "System reads STATE.md on resume and determines current position"
    - "System displays brief status summary showing phase and next action"
    - "System loads correct guideline for current workflow stage"
    - "System handles missing/corrupted STATE.md with recovery options"
    - "System orchestrates sequential workflow execution"
    - "System validates artifacts before phase transitions"
  artifacts:
    - path: "gsd/scripts/resume-manager.js"
      provides: "Resume workflow from STATE.md checkpoint"
      min_lines: 100
      exports: ["resumeWorkflow", "generateStatusSummary", "recoverFromCorruption"]
    - path: "gsd/scripts/workflow-orchestrator.js"
      provides: "Sequential workflow orchestration with validation"
      min_lines: 150
      exports: ["startWorkflow", "executePhase", "transitionPhase", "validatePhaseCompletion"]
  key_links:
    - from: "gsd/scripts/resume-manager.js"
      to: "state-manager.js"
      via: "readState import"
      pattern: "import.*readState.*from.*state-manager"
    - from: "gsd/scripts/resume-manager.js"
      to: "guideline-loader.js"
      via: "loadGuideline import"
      pattern: "import.*loadGuideline.*from.*guideline-loader"
    - from: "gsd/scripts/workflow-orchestrator.js"
      to: "validator.js"
      via: "validateArtifact import"
      pattern: "import.*validateArtifact.*from.*validator"
    - from: "gsd/scripts/workflow-orchestrator.js"
      to: "trigger-detector.js"
      via: "checkWorkflowConflict import"
      pattern: "import.*checkWorkflowConflict.*from.*trigger-detector"
---

<objective>
Create resume manager and workflow orchestrator that enable seamless workflow continuation from checkpoints and sequential phase execution with validation gates.

Purpose: Complete the workflow orchestration system by connecting trigger detection, state management, and validation into a cohesive execution flow.
Output: resume-manager.js and workflow-orchestrator.js modules enabling full workflow lifecycle.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\workflows\execute-plan.md
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\templates\summary.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\.planning\phases\03-workflow-orchestration\03-CONTEXT.md
@C:\Projects\GSDForTabnine\.planning\phases\03-workflow-orchestration\03-RESEARCH.md
@C:\Projects\GSDForTabnine\.planning\phases\02-core-infrastructure\02-05-SUMMARY.md
@C:\Projects\GSDForTabnine\gsd\scripts\state-manager.js
@C:\Projects\GSDForTabnine\gsd\scripts\guideline-loader.js
@C:\Projects\GSDForTabnine\gsd\scripts\validator.js
@C:\Projects\GSDForTabnine\gsd\scripts\trigger-detector.js
@C:\Projects\GSDForTabnine\gsd\scripts\file-ops.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resume-manager.js for checkpoint-based resume</name>
  <files>gsd/scripts/resume-manager.js</files>
  <action>
Create resume-manager.js implementing workflow resume from STATE.md checkpoints.

**Core functions:**

1. **resumeWorkflow(projectRoot)** - Resume from checkpoint
   - Use state-manager.js readState() to load current state
   - Validate state structure exists (phase > 0, status not 'pending')
   - If no active workflow: throw error "No active workflow found. Use 'start GSD' to begin a new project."
   - Determine workflow type from state: `determineWorkflowType(state)`
   - Load guideline using guideline-loader.js loadGuideline()
   - Generate status summary: `generateStatusSummary(state, guideline)`
   - Determine next action: `determineNextAction(state)`
   - Return: `{ state, guideline, summary, nextAction }`
   - Handle STATE.md corruption with recovery options (see recoverFromCorruption)

2. **generateStatusSummary(state, guideline)** - Brief checkpoint (CONTEXT.md)
   - Format:
     ```
     üìç Current Position
     Phase: X (guideline.metadata.workflow)
     Status: state.status
     Last activity: state.step

     ‚è≠Ô∏è  Next Action
     [nextAction]
     ```
   - Keep it brief (CONTEXT.md: "Brief checkpoint - not full status/history")
   - Return formatted string

3. **determineNextAction(state)** - What to do next
   - If state.status === 'completed': "Phase X complete. Ready to transition to Phase Y."
   - If state.status === 'blocked': "Workflow blocked: [state.step]. Resolve blocker to continue."
   - If state.status === 'in_progress': "Continue [state.step]"
   - Return action string

4. **determineWorkflowType(state)** - Which guideline to load
   - If state.phase === 0 or state.plan === 0: return 'newProject'
   - If state.status === 'completed': return 'planPhase' (plan next phase)
   - If state.status === 'in_progress': return 'executePhase'
   - Default: return 'planPhase'

5. **recoverFromCorruption(projectRoot, stateError)** - Recovery options
   - Detect corruption type from error message
   - Return recovery options object:
     ```javascript
     {
       error: true,
       corruption: true,
       message: 'STATE.md corrupted. Recovery options:',
       options: [
         '1. Restore from backup: node gsd/scripts/resume-manager.js --recover',
         '2. View corruption: cat .planning/STATE.md',
         '3. Restart workflow: node gsd/scripts/workflow-orchestrator.js --restart'
       ]
     }
     ```
   - DO NOT automatically recover (CONTEXT.md: "User approval for recovery actions")

**Imports:**
- `import { readState } from './state-manager.js'`
- `import { loadGuideline } from './guideline-loader.js'`
- `import path from 'node:path'`

**Error handling:**
- Catch STATE.md not found: Provide clear "use 'start GSD'" message
- Catch parse errors: Trigger recoverFromCorruption
- All errors include remediation guidance

**WHY brief checkpoint:** CONTEXT.md specifies "brief checkpoint" to avoid overwhelming user with history. Show current position and next action only (RESEARCH.md Example 3).
  </action>
  <verify>
```bash
# Test resume from actual STATE.md
node -e "
import { resumeWorkflow, generateStatusSummary } from './gsd/scripts/resume-manager.js';

try {
  const result = await resumeWorkflow(process.cwd());
  console.log('Test 1 (resume workflow):', result.state && result.guideline ? 'PASS' : 'FAIL');
  console.log('Test 2 (summary format):', result.summary.includes('üìç') ? 'PASS' : 'FAIL');
  console.log('Test 3 (next action):', result.nextAction.length > 0 ? 'PASS' : 'FAIL');
} catch (error) {
  console.log('Resume test:', error.message);
}
"
```

All 3 tests should PASS (STATE.md exists and is valid).
  </verify>
  <done>
- resume-manager.js exists with 5 exported functions
- Reads STATE.md and determines current position
- Generates brief status summary (not full history)
- Loads correct guideline for workflow stage
- Provides recovery options for corruption (no automatic recovery)
- All verification tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflow-orchestrator.js for sequential execution</name>
  <files>gsd/scripts/workflow-orchestrator.js</files>
  <action>
Create workflow-orchestrator.js implementing sequential workflow orchestration with validation gates.

**Core functions:**

1. **startWorkflow(projectRoot, userConfirmation)** - Initialize new workflow
   - Check for existing workflow using trigger-detector.js checkWorkflowConflict()
   - If conflict exists: throw error with conflict message
   - If not confirmed: throw error "Workflow start requires confirmation"
   - Load 'newProject' guideline using guideline-loader.js
   - Initialize STATE.md with phase: 0, plan: 0, status: 'pending', step: 'Initialization'
   - Use state-manager.js writeState()
   - Return: `{ guideline, message: 'Workflow started. Begin with new-project workflow.' }`

2. **executePhase(projectRoot, phaseNumber)** - Execute single phase
   - Load current state using state-manager.js readState()
   - Verify phase transition is valid: `validatePhaseTransition(state, phaseNumber)`
   - Load guideline for phase type (planPhase or executePhase)
   - Update state to in_progress: `updateProgress(projectRoot, phaseNumber, 1, 'in_progress', 'Executing phase')`
   - Return: `{ guideline, phase: phaseNumber, status: 'in_progress' }`
   - DO NOT automatically execute - return guideline for Tabnine to follow

3. **validatePhaseCompletion(projectRoot, phaseNumber, requiredArtifacts)** - Validate before transition
   - For each artifact in requiredArtifacts array:
     - Call validator.js validateArtifact(projectRoot, filePath, artifactType)
     - Accumulate errors
   - Call validator.js validateRequirementCoverage() if phaseNumber is final phase
   - If any errors: throw with all accumulated errors + remediation
   - If all pass: return `{ valid: true, artifacts: requiredArtifacts.length }`

4. **transitionPhase(projectRoot, fromPhase, toPhase, completionNote)** - Move to next phase
   - Validate current phase completion: call validatePhaseCompletion()
   - If validation fails: throw error (DO NOT transition)
   - Update state using state-manager.js transitionPhase(fromPhase, toPhase)
   - Update status to 'pending' for next phase
   - Write completion note to state: updateProgress(..., 'pending', completionNote)
   - Return: `{ transitioned: true, from: fromPhase, to: toPhase }`

5. **validatePhaseTransition(state, targetPhase)** - Prevent invalid jumps
   - If targetPhase > state.phase + 1: throw "Invalid transition: Phase X to Phase Y. Complete Phase Z first."
   - If targetPhase < state.phase: throw "Cannot move backward from Phase X to Phase Y"
   - Return true if valid

**Imports:**
- `import { readState, writeState, updateProgress, transitionPhase as stateTransition } from './state-manager.js'`
- `import { loadGuideline } from './guideline-loader.js'`
- `import { validateArtifact, validateRequirementCoverage } from './validator.js'`
- `import { checkWorkflowConflict } from './trigger-detector.js'`
- `import path from 'node:path'`

**Error handling:**
- Block invalid transitions (don't warn - block) per RESEARCH.md recommendation
- Accumulate validation errors before throwing (show all issues at once)
- Provide specific remediation for each error type

**WHY sequential execution:** Tabnine constraint - no sub-agent spawning (STATE.md decision). Orchestrator returns guideline for Tabnine to follow, rather than spawning executors (ROADMAP Phase 3 dependencies).
  </action>
  <verify>
```bash
# Test workflow orchestration
node -e "
import { validatePhaseCompletion, validatePhaseTransition } from './gsd/scripts/workflow-orchestrator.js';

// Test phase transition validation (valid)
const validState = { phase: 2, plan: 5, status: 'completed' };
try {
  validatePhaseTransition(validState, 3);
  console.log('Test 1 (valid transition 2->3): PASS');
} catch (error) {
  console.log('Test 1 (valid transition 2->3): FAIL -', error.message);
}

// Test phase transition validation (invalid jump)
try {
  validatePhaseTransition(validState, 5);
  console.log('Test 2 (invalid jump 2->5): FAIL - should have thrown');
} catch (error) {
  console.log('Test 2 (invalid jump 2->5): PASS');
}

// Test phase completion validation
try {
  const result = await validatePhaseCompletion(process.cwd(), 1, [
    { filePath: '.planning/PROJECT.md', type: 'PROJECT.md' },
    { filePath: '.planning/ROADMAP.md', type: 'ROADMAP.md' }
  ]);
  console.log('Test 3 (phase completion valid):', result.valid ? 'PASS' : 'FAIL');
} catch (error) {
  console.log('Test 3 (phase completion):', error.message);
}
"
```

Tests 1, 2, 3 should PASS.
  </verify>
  <done>
- workflow-orchestrator.js exists with 5 exported functions
- Prevents workflow conflicts on start
- Validates phase transitions (blocks invalid jumps)
- Validates artifact completion before phase transitions
- Sequential execution model (returns guideline, no sub-agents)
- All verification tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for orchestration</name>
  <files>gsd/scripts/integration-test.js</files>
  <action>
Add Test Suite 9 to integration-test.js for resume and orchestration.

**Insert after Test Suite 8:**

```javascript
// === Test Suite 9: Resume & Orchestration ===
console.log('\n=== Test Suite 9: Resume & Orchestration ===');

try {
  const { resumeWorkflow, generateStatusSummary, determineNextAction } = await import('./resume-manager.js');
  const { validatePhaseTransition, validatePhaseCompletion } = await import('./workflow-orchestrator.js');

  // Test 1: Resume workflow from STATE.md
  try {
    const result = await resumeWorkflow(process.cwd());
    if (result.state && result.guideline && result.summary && result.nextAction) {
      console.log('  ‚úì Resume workflow from STATE.md');
      testsPassed++;
    } else {
      console.log('  ‚úó Resume workflow from STATE.md - FAILED: missing fields');
      testsFailed++;
      failures.push('Resume: missing required fields in result');
    }
  } catch (error) {
    console.log('  ‚úó Resume workflow from STATE.md - FAILED:', error.message);
    testsFailed++;
    failures.push('Resume: ' + error.message);
  }

  // Test 2: Status summary format
  const testState = { phase: 2, plan: 5, status: 'completed', step: 'Integration testing' };
  const testGuideline = { metadata: { workflow: 'executePhase' } };
  const summary = generateStatusSummary(testState, testGuideline);
  if (summary.includes('üìç') && summary.includes('Phase: 2')) {
    console.log('  ‚úì Status summary format includes icon and phase');
    testsPassed++;
  } else {
    console.log('  ‚úó Status summary format - FAILED');
    testsFailed++;
    failures.push('Resume: status summary format invalid');
  }

  // Test 3: Next action determination
  const nextAction = determineNextAction(testState);
  if (nextAction.includes('Phase 2 complete') && nextAction.includes('Phase 3')) {
    console.log('  ‚úì Next action determination (completed state)');
    testsPassed++;
  } else {
    console.log('  ‚úó Next action determination - FAILED');
    testsFailed++;
    failures.push('Resume: next action determination failed');
  }

  // Test 4: Valid phase transition (2 -> 3)
  try {
    validatePhaseTransition({ phase: 2, status: 'completed' }, 3);
    console.log('  ‚úì Valid phase transition (2 -> 3)');
    testsPassed++;
  } catch (error) {
    console.log('  ‚úó Valid phase transition - FAILED:', error.message);
    testsFailed++;
    failures.push('Orchestrator: valid transition rejected');
  }

  // Test 5: Invalid phase transition (2 -> 5)
  try {
    validatePhaseTransition({ phase: 2, status: 'completed' }, 5);
    console.log('  ‚úó Invalid phase transition - FAILED: should have thrown');
    testsFailed++;
    failures.push('Orchestrator: invalid transition not blocked');
  } catch (error) {
    console.log('  ‚úì Invalid phase transition blocked (2 -> 5)');
    testsPassed++;
  }

  // Test 6: Phase completion validation
  try {
    const result = await validatePhaseCompletion(process.cwd(), 1, [
      { filePath: '.planning/PROJECT.md', type: 'PROJECT.md' }
    ]);
    if (result.valid === true) {
      console.log('  ‚úì Phase completion validation');
      testsPassed++;
    } else {
      console.log('  ‚úó Phase completion validation - FAILED');
      testsFailed++;
      failures.push('Orchestrator: phase completion validation failed');
    }
  } catch (error) {
    console.log('  ‚úó Phase completion validation - FAILED:', error.message);
    testsFailed++;
    failures.push('Orchestrator: ' + error.message);
  }

} catch (error) {
  console.log('  ‚úó Resume & orchestration tests - ERROR:', error.message);
  testsFailed += 6;
  failures.push(`Resume/orchestration error: ${error.message}`);
}
```

**Update test counts:**
- Change "Total tests: 37" to "Total tests: 43"
- Tests now: 27 (Phase 2) + 5 (trigger) + 5 (validation) + 6 (orchestration) = 43
  </action>
  <verify>
```bash
node gsd/scripts/integration-test.js
```

Should show:
- Test Suite 9: Resume & Orchestration (6 tests)
- Total tests: 43
- Passed: 43 (100%)
  </verify>
  <done>
- integration-test.js includes Test Suite 9 with 6 orchestration tests
- All 43 tests pass (27 Phase 2 + 5 trigger + 5 validation + 6 orchestration)
- Tests cover resume workflow, status summary, next action, phase transitions (valid/invalid), phase completion validation
  </done>
</task>

</tasks>

<verification>
**Functional checks:**
1. Resume workflow works: `node -e "import { resumeWorkflow } from './gsd/scripts/resume-manager.js'; const r = await resumeWorkflow(process.cwd()); console.log('PASS');"` prints PASS
2. Phase transition validation: Invalid jumps are blocked
3. Artifact validation before transitions: validatePhaseCompletion() enforces validation
4. Integration tests pass: `node gsd/scripts/integration-test.js` shows 43/43 passed
5. Status summary is brief (not full history)

**Requirements validated:**
- RESUME-01: Reads STATE.md and determines position ‚úì
- RESUME-02: Continues from checkpoint without re-explanation ‚úì
- RESUME-03: Displays status summary (brief) ‚úì
- RESUME-04: Handles corrupted STATE.md with recovery options ‚úì
</verification>

<success_criteria>
- [ ] resume-manager.js exists with 5 exported functions
- [ ] workflow-orchestrator.js exists with 5 exported functions
- [ ] Resume workflow loads state and guideline
- [ ] Status summary is brief (current position + next action)
- [ ] Phase transition validation blocks invalid jumps
- [ ] Artifact validation enforced before phase transitions
- [ ] Recovery options provided for STATE.md corruption (no auto-recovery)
- [ ] All 43 integration tests pass (27 Phase 2 + 5 trigger + 5 validation + 6 orchestration)
- [ ] Requirements RESUME-01 through RESUME-04 fulfilled
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-03-SUMMARY.md`
</output>
