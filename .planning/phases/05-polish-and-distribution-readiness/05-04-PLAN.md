---
phase: 05-polish-and-distribution-readiness
plan: 04
type: execute
wave: 2
depends_on: [05-03]
files_modified:
  - .github/workflows/ci.yml
  - gsd/scripts/pre-publish-check.js
  - gsd/package.json
  - gsd/scripts/integration-test.js
autonomous: true

must_haves:
  truths:
    - "CI tests run on Windows, Linux, and macOS platforms"
    - "Tests pass on all three platforms before merge"
    - "Pre-publish validation prevents accidental file inclusion"
    - "Package size is checked and reported before publish"
    - "Integration tests work in CI environment (not just local)"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Cross-platform CI matrix"
      contains: ["ubuntu-latest", "windows-latest", "macos-latest"]
    - path: "gsd/scripts/pre-publish-check.js"
      provides: "Pre-publish validation script"
      min_lines: 60
      exports: []
    - path: "gsd/package.json"
      provides: "Script configuration"
      contains: ["prepack"]
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "gsd/scripts/integration-test.js"
      via: "npm test invocation"
      pattern: "npm test"
    - from: "gsd/package.json"
      to: "gsd/scripts/pre-publish-check.js"
      via: "prepack hook"
      pattern: "prepack.*pre-publish-check"
---

<objective>
Validate cross-platform compatibility and package quality before distribution.

Purpose: Ensure library works on all platforms (Windows, Linux, macOS), prevent publishing sensitive files, validate package size, and make integration tests CI-friendly.

Output: Cross-platform CI matrix, pre-publish validation script, CI-compatible integration tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-polish-and-distribution-readiness/05-RESEARCH.md
@.planning/phases/05-polish-and-distribution-readiness/05-02-SUMMARY.md
@.planning/phases/05-polish-and-distribution-readiness/05-03-SUMMARY.md

# CI workflow from Plan 2 (will enhance)
@.github/workflows/ci.yml

# Package configuration
@gsd/package.json

# Integration tests to make CI-friendly
@gsd/scripts/integration-test.js
</context>

<tasks>

<task type="auto">
  <name>Enhance CI workflow with cross-platform matrix</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Verify and enhance .github/workflows/ci.yml with comprehensive cross-platform testing.

CI workflow was created in Plan 2 (05-02). Verify it has:
1. Matrix with ubuntu-latest, windows-latest, macos-latest
2. Node version 24.x
3. npm ci for dependency installation
4. npm test for running tests

If any elements missing, add them.

Additionally, add fail-fast: false to matrix strategy to see results from all platforms even if one fails:

```yaml
strategy:
  fail-fast: false
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node-version: [24.x]
```

Add step to display platform info for debugging:
```yaml
- name: Platform info
  run: |
    echo "OS: ${{ matrix.os }}"
    echo "Node: ${{ matrix.node-version }}"
    node --version
    npm --version
```

Why fail-fast: false: Allows seeing Windows-specific failures even if Linux passes, or vice versa. Better debugging.

Why platform info: Helps diagnose version-specific or OS-specific issues from CI logs.

Ensure working directory handling for Windows:
- All `cd gsd` commands work on Windows (backslashes handled by shell)
- Use `|` multiline syntax for cross-platform compatibility
  </action>
  <verify>cat .github/workflows/ci.yml | grep "fail-fast: false" && cat .github/workflows/ci.yml | grep "macos-latest"</verify>
  <done>.github/workflows/ci.yml tests on all three platforms with fail-fast disabled</done>
</task>

<task type="auto">
  <name>Create pre-publish validation script</name>
  <files>gsd/scripts/pre-publish-check.js</files>
  <action>
Create gsd/scripts/pre-publish-check.js to validate package before publishing.

Based on 05-RESEARCH.md Example 1 (Testing Package Contents Before Publish).

Script validates:
1. Package contents (no sensitive files)
2. Package size (warn if >5MB, error if >10MB)
3. Required files present (LICENSE, README.md, QUICKSTART.md)
4. Exports field matches actual files

```javascript
/**
 * Pre-Publish Validation
 *
 * Validates package contents and size before publishing to npm.
 * Run automatically via prepack hook in package.json.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { readFile, access, unlink } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const gsdRoot = join(__dirname, '..');

async function checkPackageContents() {
  console.log('üì¶ Validating package contents...\n');

  // Generate tarball preview
  const { stdout } = await execAsync('npm pack --dry-run', { cwd: gsdRoot });

  console.log('Package contents:');
  console.log(stdout);
  console.log('');

  // Check for sensitive files (security)
  const sensitivePatterns = ['.env', 'credentials', 'secrets', '.key', 'token'];
  for (const pattern of sensitivePatterns) {
    if (stdout.toLowerCase().includes(pattern)) {
      throw new Error(\`‚ùå SECURITY: Package may contain sensitive file: \${pattern}\`);
    }
  }

  // Check for dev files that shouldn't be published
  const devPatterns = ['.planning', 'integration-test.js', '.git'];
  const foundDev = devPatterns.filter(p => stdout.includes(p));
  if (foundDev.length > 0) {
    throw new Error(\`‚ùå DEV FILES: Package contains dev files: \${foundDev.join(', ')}\`);
  }

  console.log('‚úÖ No sensitive or dev files detected\n');
}

async function checkPackageSize() {
  console.log('üìä Checking package size...\n');

  // Create actual tarball to measure size
  const { stdout } = await execAsync('npm pack', { cwd: gsdRoot });
  const tarball = stdout.trim();
  const tarballPath = join(gsdRoot, tarball);

  try {
    const buffer = await readFile(tarballPath);
    const sizeBytes = buffer.length;
    const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);

    console.log(\`Package size: \${sizeMB}MB\`);

    // Cleanup tarball
    await unlink(tarballPath);

    // Size thresholds
    if (sizeBytes > 10 * 1024 * 1024) { // 10MB
      throw new Error(\`‚ùå PACKAGE TOO LARGE: \${sizeMB}MB exceeds 10MB limit\`);
    }

    if (sizeBytes > 5 * 1024 * 1024) { // 5MB
      console.warn(\`‚ö†Ô∏è  WARNING: Package is large (\${sizeMB}MB). Consider excluding unnecessary files.\n\`);
    } else {
      console.log(\`‚úÖ Package size acceptable (\${sizeMB}MB)\n\`);
    }
  } catch (err) {
    if (err.code === 'ENOENT') {
      throw new Error('Failed to read package tarball');
    }
    throw err;
  }
}

async function checkRequiredFiles() {
  console.log('üìã Checking required files...\n');

  const required = ['LICENSE', 'README.md', 'QUICKSTART.md', 'package.json'];

  for (const file of required) {
    const filePath = join(gsdRoot, file);
    try {
      await access(filePath);
      console.log(\`‚úÖ \${file}\`);
    } catch {
      throw new Error(\`‚ùå MISSING: Required file \${file} not found\`);
    }
  }

  console.log('');
}

async function validateExports() {
  console.log('üîó Validating exports field...\n');

  const pkgPath = join(gsdRoot, 'package.json');
  const pkg = JSON.parse(await readFile(pkgPath, 'utf-8'));

  if (!pkg.exports) {
    throw new Error('‚ùå package.json missing exports field');
  }

  // Check that exported files exist
  for (const [key, value] of Object.entries(pkg.exports)) {
    const filePath = join(gsdRoot, value);
    try {
      await access(filePath);
      console.log(\`‚úÖ Export "\${key}" -> \${value}\`);
    } catch {
      throw new Error(\`‚ùå BROKEN EXPORT: "\${key}" points to non-existent file: \${value}\`);
    }
  }

  console.log('');
}

async function runChecks() {
  try {
    await checkRequiredFiles();
    await validateExports();
    await checkPackageContents();
    await checkPackageSize();

    console.log('‚úÖ All pre-publish checks passed!\n');
    process.exit(0);
  } catch (err) {
    console.error(\`\n\${err.message}\n\`);
    process.exit(1);
  }
}

runChecks();
```

This script validates everything before publishing, preventing common mistakes (missing files, sensitive data leaks, bloated packages).
  </action>
  <verify>cat gsd/scripts/pre-publish-check.js | grep "checkPackageContents" && cat gsd/scripts/pre-publish-check.js | grep "sensitivePatterns"</verify>
  <done>gsd/scripts/pre-publish-check.js validates package before publish</done>
</task>

<task type="auto">
  <name>Add pre-publish hook to package.json</name>
  <files>gsd/package.json</files>
  <action>
Add prepack hook to gsd/package.json to run pre-publish validation automatically.

Add to scripts section:
```json
"prepack": "node scripts/pre-publish-check.js"
```

Why prepack instead of prepublishOnly:
- prepack runs before `npm pack` AND `npm publish`
- Catches issues during local testing (`npm pack`) before publish attempt
- prepublishOnly only runs on `npm publish`, missing local pack testing

Keep existing prepublishOnly for running tests:
```json
"prepublishOnly": "npm test",
"prepack": "node scripts/pre-publish-check.js"
```

Execution order when running `npm publish`:
1. prepack -> runs pre-publish-check.js (validates package contents/size)
2. Creates tarball
3. prepublishOnly -> runs npm test (validates code works)
4. Publishes to npm

Both hooks provide safety gates - validation before packing, tests before publishing.
  </action>
  <verify>cat gsd/package.json | grep '"prepack"' && cat gsd/package.json | grep "pre-publish-check.js"</verify>
  <done>package.json has prepack hook running pre-publish validation</done>
</task>

<task type="auto">
  <name>Make integration tests CI-friendly</name>
  <files>gsd/scripts/integration-test.js</files>
  <action>
Update gsd/scripts/integration-test.js to work in CI environments.

Current integration-test.js may assume:
- Relative paths from execution directory
- Specific directory structure
- Local development environment

CI-friendly changes:

1. **Fix path resolution** - use import.meta.url for reliable paths:
```javascript
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// All paths relative to script location
const templatesDir = join(__dirname, '../templates');
const guidelinesDir = join(__dirname, '../guidelines');
```

2. **Add CI detection** - show better output in CI:
```javascript
const isCI = process.env.CI === 'true' || process.env.GITHUB_ACTIONS === 'true';

// Use CI-friendly output (no emojis, clear status)
function log(msg) {
  if (isCI) {
    console.log(msg.replace(/[^\x00-\x7F]/g, '')); // Remove emojis
  } else {
    console.log(msg);
  }
}
```

3. **Exit codes** - ensure proper exit codes:
```javascript
// At end of test suite
if (failureCount > 0) {
  process.exit(1); // Non-zero exit code fails CI
} else {
  process.exit(0); // Explicit success
}
```

4. **Windows path handling** - ensure all path.join() usage (should already be correct from Phase 2, verify):
```javascript
// GOOD (works on Windows and Unix)
const templatePath = join(templatesDir, 'PROJECT.md');

// BAD (breaks on Windows)
// const templatePath = templatesDir + '/PROJECT.md';
```

Check existing integration-test.js and apply these patterns if not already present. Phase 2 likely already has correct path handling, but verify for CI environment support.

Focus on:
- Explicit exit codes (0 for success, 1 for failure)
- Path resolution from script location (not cwd)
- CI-friendly output
  </action>
  <verify>cat gsd/scripts/integration-test.js | grep "process.exit" && cat gsd/scripts/integration-test.js | grep "import.meta.url"</verify>
  <done>integration-test.js works reliably in CI environments on all platforms</done>
</task>

</tasks>

<verification>
1. Validate CI workflow:
   - `cat .github/workflows/ci.yml | grep "fail-fast: false"` confirms setting
   - Workflow has all three OS platforms
2. Test pre-publish validation locally:
   - `cd gsd && node scripts/pre-publish-check.js`
   - Should pass all checks
   - Should report package size
3. Test package creation:
   - `cd gsd && npm pack`
   - Should run prepack hook automatically
   - Tarball should be created
   - Check tarball contents: `tar -tzf gsd-for-tabnine-*.tgz | head -20`
4. Run integration tests:
   - `cd gsd && npm test`
   - All 57 tests should pass
   - Exit code should be 0
5. Simulate CI environment:
   - `CI=true npm test` (from gsd/)
   - Output should be CI-friendly (no emoji issues)
</verification>

<success_criteria>
- CI workflow tests on Windows, Linux, macOS with fail-fast: false
- pre-publish-check.js validates package contents, size, required files, exports
- prepack hook runs validation automatically before pack/publish
- integration-test.js works in CI environment with proper exit codes
- All tests pass on all three platforms
- Package size is reasonable (<5MB, error if >10MB)
- No sensitive files in package tarball
</success_criteria>

<output>
After completion, create `.planning/phases/05-polish-and-distribution-readiness/05-04-SUMMARY.md`
</output>
