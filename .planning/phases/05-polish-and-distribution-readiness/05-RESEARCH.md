# Phase 5: Polish and Distribution Readiness - Research

**Researched:** 2026-01-20
**Domain:** npm package publishing, open-source distribution, developer experience
**Confidence:** HIGH

## Summary

Phase 5 prepares the GSD for Tabnine library for production use and public distribution on npm. Research focused on five key domains: essential files for open-source distribution, npm publishing best practices, documentation and examples, testing coverage, and developer experience improvements.

The standard approach for 2026 involves: (1) using trusted publishing with OIDC instead of long-lived tokens for secure automation, (2) providing comprehensive documentation with quick-start guides, (3) maintaining package quality with semantic versioning and automated changelogs, (4) ensuring cross-platform compatibility especially for Windows users, and (5) optimizing package size and developer experience.

Key 2026 advancements include npm's trusted publishing (GA July 2025) which eliminates token management, automatic provenance attestations for supply chain security, and industry adoption of semantic-release for fully automated version management. The testing strategy has evolved to emphasize a testing pyramid: comprehensive unit/integration tests with minimal focused E2E tests for critical flows.

**Primary recommendation:** Implement automated publishing via GitHub Actions with trusted publishing (OIDC), use semantic-release for versioning and changelog generation, provide comprehensive README and quickstart documentation, and ensure cross-platform (Windows/Linux/macOS) compatibility validation.

## Standard Stack

The established libraries/tools for npm package distribution in 2026:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| semantic-release | latest | Automated versioning & publishing | Industry standard for release automation; analyzes commits, determines versions, generates changelogs |
| @semantic-release/npm | latest | npm publish plugin | Official plugin for semantic-release npm integration |
| @semantic-release/changelog | latest | CHANGELOG.md generation | Automates changelog from conventional commits |
| @semantic-release/git | latest | Git commits for releases | Commits updated package.json and CHANGELOG.md back to repo |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| vitest | latest | Test runner & benchmarks | Modern ESM-first testing; 10-20x faster than Jest; built-in benchmark support |
| bundlephobia-cli | latest | Bundle size analysis | Pre-publish validation of package size impact |
| @dabh/diagnostics | 2.0.8 | Debugging utility | Production-ready diagnostic logging with 3M+ weekly downloads |
| commander | latest | CLI framework | If building CLI wrapper; established, feature-rich |
| inquirer | latest | Interactive prompts | If building setup wizard; comprehensive prompt system |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| semantic-release | manual versioning | More control but error-prone, no automation |
| vitest | jest | Jest more established but slower, CJS-focused |
| trusted publishing | npm tokens | Tokens work but security risk, require rotation |

**Installation:**
```bash
# Core release automation
npm install --save-dev semantic-release @semantic-release/npm @semantic-release/changelog @semantic-release/git

# Testing & quality
npm install --save-dev vitest bundle-phobia-cli

# Optional: CLI tooling
npm install commander inquirer
```

## Architecture Patterns

### Recommended Project Structure
```
gsd/
‚îú‚îÄ‚îÄ package.json          # Distribution metadata
‚îú‚îÄ‚îÄ .npmignore           # Exclude dev files (or use files field)
‚îú‚îÄ‚îÄ LICENSE              # Required: MIT/Apache 2.0
‚îú‚îÄ‚îÄ README.md            # Primary documentation
‚îú‚îÄ‚îÄ QUICKSTART.md        # 5-minute getting started
‚îú‚îÄ‚îÄ CHANGELOG.md         # Auto-generated by semantic-release
‚îú‚îÄ‚îÄ CONTRIBUTING.md      # Contributor guidelines
‚îú‚îÄ‚îÄ scripts/             # Core library code
‚îÇ   ‚îî‚îÄ‚îÄ *.js            # ESM modules (type: "module")
‚îú‚îÄ‚îÄ templates/           # Template files to distribute
‚îú‚îÄ‚îÄ guidelines/          # Guideline files to distribute
‚îú‚îÄ‚îÄ examples/            # Working example project
‚îÇ   ‚îî‚îÄ‚îÄ basic-usage/    # Minimal working example
‚îî‚îÄ‚îÄ test/               # Test files (excluded from package)
```

### Pattern 1: Package.json Configuration for Distribution
**What:** Properly configure package.json with all required and recommended fields for npm publishing
**When to use:** Required for all npm packages

**Example:**
```javascript
// Source: Multiple official npm docs and 2026 best practices
{
  "name": "gsd-for-tabnine",
  "version": "1.0.0",  // Managed by semantic-release
  "description": "GSD workflow system for Tabnine agent mode",
  "type": "module",     // ESM-first approach

  // CRITICAL: Entry points (exports preferred over main in 2026)
  "exports": {
    ".": "./scripts/index.js",
    "./state-manager": "./scripts/state-manager.js",
    "./template-renderer": "./scripts/template-renderer.js"
    // Other public API exports
  },
  "main": "./scripts/index.js",  // Fallback for older Node versions

  // Node version requirement
  "engines": {
    "node": ">=24.0.0"
  },

  // Distribution control (whitelist approach recommended)
  "files": [
    "scripts/",
    "templates/",
    "guidelines/",
    "README.md",
    "QUICKSTART.md",
    "LICENSE"
  ],

  // Discoverability
  "keywords": [
    "workflow",
    "tabnine",
    "gsd",
    "project-management",
    "agent",
    "automation"
  ],

  // Repository & bugs
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/gsd-for-tabnine.git"
  },
  "bugs": {
    "url": "https://github.com/yourusername/gsd-for-tabnine/issues"
  },

  // License
  "license": "MIT",

  // Scripts
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:integration": "node scripts/integration-test.js",
    "prepublishOnly": "npm test"  // Safety: test before publish
  },

  // Dependencies vs devDependencies
  "dependencies": {
    "ajv": "^8.12.0",
    "front-matter": "^4.0.2",
    "markdownlint": "^0.36.1",
    "write-file-atomic": "^5.0.1"
  },
  "devDependencies": {
    "semantic-release": "^22.0.0",
    "vitest": "latest"
  }
}
```

### Pattern 2: GitHub Actions Trusted Publishing Workflow
**What:** Automated publishing using OIDC authentication instead of tokens
**When to use:** All production npm packages published from CI/CD

**Example:**
```yaml
# Source: npm trusted publishing docs, GitHub Actions semantic-release recipes
# .github/workflows/release.yml
name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write      # Needed for semantic-release to push commits/tags
  issues: write        # Needed for release comments
  pull-requests: write # Needed for PR comments
  id-token: write      # CRITICAL: Enables OIDC trusted publishing

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for semantic-release

      - uses: actions/setup-node@v4
        with:
          node-version: '24'

      - run: npm ci

      - run: npm test

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # NO NPM_TOKEN needed with trusted publishing!
        run: npx semantic-release
```

### Pattern 3: Semantic Release Configuration
**What:** Configure semantic-release for automated versioning and changelog
**When to use:** Standard for all modern npm packages

**Example:**
```javascript
// Source: semantic-release official documentation
// .releaserc.json
{
  "branches": ["main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/npm",
    [
      "@semantic-release/git",
      {
        "assets": ["package.json", "package-lock.json", "CHANGELOG.md"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ],
    "@semantic-release/github"
  ]
}
```

### Pattern 4: Quick Start Documentation Structure
**What:** Provide users with minimal time-to-value documentation
**When to use:** All libraries that require setup or configuration

**Structure:**
```markdown
# QUICKSTART.md

<!-- 2026 Best Practice: Start with time estimate and prerequisites -->

**Time to first result:** 5 minutes
**Prerequisites:** Node.js 24+, Tabnine installed

## Installation

```bash
npm install -g gsd-for-tabnine
```

## Quick Setup (3 steps)

### 1. Initialize GSD
```bash
gsd init
```

### 2. Create symlink to Tabnine
<!-- Windows/Linux/macOS instructions -->

### 3. Start workflow in Tabnine
```
Type "start GSD" in Tabnine chat
```

## Next Steps
- Full documentation: [README.md](README.md)
- Examples: [examples/](examples/)
- Troubleshooting: [FAQ section]
```

### Pattern 5: Cross-Platform Path Handling
**What:** Ensure code works on Windows, Linux, and macOS
**When to use:** All Node.js libraries that interact with file system

**Example:**
```javascript
// Source: Cross-platform Node.js best practices
import { resolve, join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// ESM __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// GOOD: Cross-platform path joining
const templatePath = join(__dirname, '../templates', 'PROJECT.md');

// GOOD: Cross-platform path resolution
const absolutePath = resolve(process.cwd(), '.planning', 'STATE.md');

// BAD: Hardcoded separators
// const badPath = __dirname + '\\templates\\PROJECT.md';  // Breaks on Unix
```

### Anti-Patterns to Avoid

- **Publishing without provenance:** In 2026, provenance attestations are standard. Use trusted publishing to get them automatically.
- **Manual version bumping:** Don't manually edit package.json version. Use semantic-release or similar automation.
- **Mixing .npmignore and package.json files field:** These are NOT cumulative. Adding .npmignore replaces .gitignore entirely. Choose one approach (files field recommended).
- **Long-lived npm tokens in CI:** Security risk. Use trusted publishing with OIDC instead.
- **No prepublishOnly hook:** Always run tests before publishing. Add `"prepublishOnly": "npm test"`.
- **Hardcoded file paths:** Use path.join() and path.resolve() for cross-platform compatibility.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Release versioning | Manual version management script | semantic-release | Handles semantic versioning, changelogs, git tags, GitHub releases, npm publish - fully automated |
| Changelog generation | String concatenation from git log | @semantic-release/changelog or conventional-changelog | Parses conventional commits correctly, handles breaking changes, groups by type |
| Package size analysis | Custom bundle analyzer | bundlephobia or bundlephobia-cli | Comprehensive analysis including dependencies, tree-shaking opportunities, version comparisons |
| CLI argument parsing | Manual process.argv parsing | commander or yargs | Handles subcommands, options, help generation, validation |
| Interactive prompts | Custom readline wrapper | inquirer or prompts | Rich prompt types (select, confirm, input, password, etc.), built-in validation |
| Cross-platform scripts | Platform detection + conditionals | Use path module + tools like cross-env | Handles path separators, environment variables, platform quirks |
| File exclusion logic | Custom ignore parser | Use package.json "files" field | npm's native, well-tested, simple whitelist approach |

**Key insight:** The npm ecosystem has mature, battle-tested solutions for distribution. Custom solutions miss edge cases (e.g., semantic-release handles pre-release versions, monorepos, CI failures, rollbacks). Use proven tools.

## Common Pitfalls

### Pitfall 1: Publishing Unintended Files
**What goes wrong:** Sensitive files (.env, credentials, large test fixtures) or unnecessary files (node_modules, .git) get published to npm
**Why it happens:** Misunderstanding of .gitignore vs .npmignore vs files field interaction
**How to avoid:**
1. Use package.json "files" field (whitelist approach - safest)
2. Test before publishing: `npm pack --dry-run` or `npm pack` then inspect tarball
3. Never rely on .gitignore alone (doesn't exclude all dev files)
**Warning signs:** Package size unexpectedly large (>100KB for config-based packages), "npm pack" output shows unexpected files

### Pitfall 2: Missing Engines Field
**What goes wrong:** Users install package on incompatible Node.js versions, leading to cryptic errors
**Why it happens:** Assuming users have latest Node.js, or using features (e.g., ESM, top-level await) not available in older versions
**How to avoid:**
1. Add explicit "engines": {"node": ">=24.0.0"} in package.json
2. Test on minimum supported version in CI
3. Document version requirement in README
**Warning signs:** Users report "SyntaxError: Cannot use import statement outside a module" or similar version-specific errors

### Pitfall 3: Broken Exports on Windows
**What goes wrong:** Package works in development on macOS/Linux but fails on Windows with ENOENT or path errors
**Why it happens:** Using forward slashes in hardcoded paths, or backslashes on Windows breaking on Unix
**How to avoid:**
1. ALWAYS use path.join() and path.resolve() for file paths
2. Test on Windows (GitHub Actions: runs-on: windows-latest)
3. Use path separators: path.sep instead of '/' or '\\'
**Warning signs:** CI passes but Windows users report file not found errors

### Pitfall 4: Missing TypeScript Declarations
**What goes wrong:** TypeScript users get "Could not find a declaration file" errors
**Why it happens:** Package written in JavaScript without .d.ts files, or "types" field not set in package.json
**How to avoid:**
1. If shipping TypeScript types, add "types": "./types/index.d.ts" to package.json
2. If not providing types, document this in README
3. For JavaScript packages, consider @types/your-package submission to DefinitelyTyped
**Warning signs:** GitHub issues from TypeScript users requesting type definitions

### Pitfall 5: Conventional Commit Format Not Followed
**What goes wrong:** semantic-release doesn't trigger releases or generates wrong version bumps
**Why it happens:** Commits don't follow format: `type(scope): description` (e.g., "fixed bug" instead of "fix: resolve state corruption")
**How to avoid:**
1. Use commitlint to enforce conventional commits
2. Document commit format in CONTRIBUTING.md
3. Provide examples: feat: (minor), fix: (patch), BREAKING CHANGE: (major)
**Warning signs:** semantic-release runs but no version bump, or wrong bump type (patch instead of minor)

### Pitfall 6: Trusted Publishing Not Configured
**What goes wrong:** Publishing fails with authentication error despite OIDC permissions being set
**Why it happens:** npm package settings not configured to trust GitHub Actions as publisher
**How to avoid:**
1. Go to npmjs.com ‚Üí package settings ‚Üí Trusted Publishers ‚Üí Add GitHub Actions
2. Ensure npm CLI version >=11.5.1 in CI
3. Verify id-token: write permission in workflow
**Warning signs:** "npm ERR! code ENEEDAUTH" despite permissions.id-token: write being set

### Pitfall 7: No Example Project
**What goes wrong:** Users can read documentation but struggle to implement, leading to high support burden
**Why it happens:** Assuming documentation is sufficient without showing working code
**How to avoid:**
1. Create examples/ directory with minimal working example
2. Example should run with: git clone, npm install, npm start
3. Include example in published package (add to "files" field)
**Warning signs:** High volume of "how do I use this?" issues, users requesting examples

### Pitfall 8: Package Size Bloat
**What goes wrong:** Package downloads are slow, users complain about bundle size impact
**Why it happens:** Including unnecessary dependencies, bundling development dependencies, or including large test fixtures
**How to avoid:**
1. Run bundlephobia analysis: `npx bundle-phobia-cli package-name`
2. Review package contents: `npm pack` and inspect tarball
3. Minimize dependencies, mark dev tools as devDependencies
4. Use "files" field to exclude unnecessary assets
**Warning signs:** Package >1MB for utility library, bundlephobia shows unexpected size

## Code Examples

Verified patterns from official sources:

### Example 1: Testing Package Contents Before Publish
```javascript
// Source: npm best practices documentation
// scripts/pre-publish-check.js
import { exec } from 'child_process';
import { promisify } from 'util';
import { readFile } from 'fs/promises';

const execAsync = promisify(exec);

async function checkPackageContents() {
  // Generate tarball without publishing
  const { stdout } = await execAsync('npm pack --dry-run');

  console.log('üì¶ Package contents:');
  console.log(stdout);

  // Check for sensitive files
  const sensitivePatterns = ['.env', 'credentials', 'secrets', '.key'];
  for (const pattern of sensitivePatterns) {
    if (stdout.includes(pattern)) {
      throw new Error(`‚ùå SECURITY: Package contains sensitive file: ${pattern}`);
    }
  }

  // Check package size
  const { stdout: sizeOut } = await execAsync('npm pack');
  const tarball = sizeOut.trim();
  const { size } = await readFile(tarball).then(buf => ({ size: buf.length }));
  const sizeMB = (size / 1024 / 1024).toFixed(2);

  console.log(`üìä Package size: ${sizeMB}MB`);

  if (size > 5 * 1024 * 1024) { // 5MB threshold
    console.warn(`‚ö†Ô∏è  WARNING: Package is large (${sizeMB}MB). Consider excluding unnecessary files.`);
  }

  console.log('‚úÖ Pre-publish checks passed');
}

checkPackageContents().catch(err => {
  console.error(err.message);
  process.exit(1);
});
```

### Example 2: Cross-Platform Script Runner
```javascript
// Source: Node.js cross-platform best practices
// scripts/run-command.js
import { spawn } from 'child_process';
import { platform } from 'os';

/**
 * Run command cross-platform (Windows, macOS, Linux)
 */
function runCommand(command, args = []) {
  const isWindows = platform() === 'win32';

  // Windows requires shell for built-in commands
  const shell = isWindows ? true : false;
  const cmd = isWindows ? command + '.cmd' : command;

  const proc = spawn(cmd, args, {
    shell,
    stdio: 'inherit',  // Show output in real-time
    env: process.env
  });

  return new Promise((resolve, reject) => {
    proc.on('close', code => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Command failed with code ${code}`));
      }
    });

    proc.on('error', reject);
  });
}

// Usage
await runCommand('npm', ['test']);
```

### Example 3: README Badge Section
```markdown
<!-- Source: 2026 open-source best practices -->
# GSD for Tabnine

[![npm version](https://badge.fury.io/js/gsd-for-tabnine.svg)](https://www.npmjs.com/package/gsd-for-tabnine)
[![Node.js CI](https://github.com/username/gsd-for-tabnine/actions/workflows/ci.yml/badge.svg)](https://github.com/username/gsd-for-tabnine/actions/workflows/ci.yml)
[![npm downloads](https://img.shields.io/npm/dm/gsd-for-tabnine)](https://www.npmjs.com/package/gsd-for-tabnine)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Provenance](https://img.shields.io/badge/provenance-attested-green)](https://docs.npmjs.com/generating-provenance-statements)

**Get Shit Done** workflow system for Tabnine agent mode.

[Quick Start](#installation) | [Documentation](#usage) | [Examples](examples/) | [Contributing](CONTRIBUTING.md)
```

### Example 4: CONTRIBUTING.md Template
```markdown
<!-- Source: GitHub docs and open-source guidelines -->
# Contributing to GSD for Tabnine

Thank you for your interest in contributing! This document provides guidelines for contributions.

## Ways to Contribute

- üêõ Report bugs via [GitHub Issues](https://github.com/username/gsd-for-tabnine/issues)
- üí° Suggest features or improvements
- üìù Improve documentation
- üîß Submit pull requests

## Development Setup

1. **Fork and clone:**
   ```bash
   git clone https://github.com/YOUR-USERNAME/gsd-for-tabnine.git
   cd gsd-for-tabnine/gsd
   ```

2. **Install dependencies:**
   ```bash
   npm install
   ```

3. **Run tests:**
   ```bash
   npm test
   ```

## Commit Message Format

We use [Conventional Commits](https://www.conventionalcommits.org/) for automated versioning:

- `feat: add new feature` ‚Üí minor version bump
- `fix: resolve bug` ‚Üí patch version bump
- `BREAKING CHANGE: ...` ‚Üí major version bump

**Examples:**
```
feat(state-manager): add resume from checkpoint
fix(template-renderer): handle missing variables
docs(readme): update installation instructions
```

## Pull Request Process

1. Create a feature branch: `git checkout -b feat/my-feature`
2. Make your changes with descriptive commits
3. Run tests: `npm test`
4. Push and create pull request
5. Wait for CI to pass and review

## Code of Conduct

Be respectful, inclusive, and constructive. See full [Code of Conduct](CODE_OF_CONDUCT.md).

## Questions?

Open a [GitHub Discussion](https://github.com/username/gsd-for-tabnine/discussions) for questions.
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| npm tokens in CI | Trusted publishing (OIDC) | July 2025 (GA) | No token management, automatic provenance, improved security |
| Manual changelog | semantic-release auto-generation | Standard since ~2020, dominant 2026 | Zero-effort changelogs from conventional commits |
| Jest for testing | Vitest for ESM projects | 2024-2026 transition | 10-20x faster, native ESM support, better DX |
| Extensive E2E tests | Testing pyramid: unit/integration focus | 2025-2026 shift | Faster CI, lower maintenance, focus E2E on critical flows |
| .npmignore blacklist | package.json "files" whitelist | Recommended since 2020s | Safer, explicit control, prevents accidental leaks |
| main field only | exports field with conditions | Node 12+ (2019), standard 2026 | Subpath exports, dual ESM/CJS, better encapsulation |
| pnpm benchmarks | pnpm fastest package manager | Consistent since 2023 | 3-18x faster installs than npm |

**Deprecated/outdated:**
- **prepublish script:** Use prepublishOnly instead (prepublish runs on both install and publish, causing confusion)
- **Classic npm tokens:** Deprecated October 2025; granular access tokens with max 90-day expiry, prefer trusted publishing
- **Lack of provenance:** Provenance attestations are now standard for supply chain security
- **Manual .d.ts maintenance:** TypeScript's automatic declaration generation (declaration: true) is standard

## Open Questions

Things that couldn't be fully resolved:

1. **Should package provide CLI wrapper or rely on direct script execution?**
   - What we know: commander/inquirer are standard for CLIs, current design uses direct Node.js script execution
   - What's unclear: Whether Tabnine users would benefit from `gsd init` style CLI vs. current `node gsd/scripts/state-manager.js` approach
   - Recommendation: Research in planning phase - consider user friction vs. added complexity

2. **TypeScript type definitions needed?**
   - What we know: Package is pure JavaScript (ESM), TypeScript users would benefit from .d.ts files
   - What's unclear: Priority vs. effort, whether users expect TypeScript support
   - Recommendation: LOW priority for v1.0, can add later or accept community contribution to DefinitelyTyped

3. **How minimal should example project be?**
   - What we know: examples/ directory is standard, should show working integration
   - What's unclear: Scope of example (just GSD init? full multi-phase project?)
   - Recommendation: Start minimal (single-phase demo), can expand based on user feedback

4. **Windows-specific test coverage?**
   - What we know: Cross-platform compatibility is critical, current tests run on development platform only
   - What's unclear: Extent of Windows-specific issues in codebase (path handling appears correct but untested)
   - Recommendation: HIGH priority - add GitHub Actions matrix with windows-latest

## Sources

### Primary (HIGH confidence)
- npm Docs - Trusted Publishing: https://docs.npmjs.com/trusted-publishers/
- npm Docs - Package.json: https://nodejs.org/api/packages.html
- semantic-release GitHub: https://github.com/semantic-release/semantic-release
- Node.js Official Docs - Modules: https://nodejs.org/api/packages.html
- GitHub Docs - CONTRIBUTING guidelines: https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/setting-guidelines-for-repository-contributors
- npm Docs - Deprecating packages: https://docs.npmjs.com/deprecating-and-undeprecating-packages-or-package-versions/
- TypeScript Handbook - Type Declarations: https://www.typescriptlang.org/docs/handbook/2/type-declarations.html

### Secondary (MEDIUM confidence)
- Snyk Blog - Modern npm Package 2024: https://snyk.io/blog/best-practices-create-modern-npm-package/
- Keep a Changelog: https://keepachangelog.com/en/1.0.0/
- GitHub - awesome-cross-platform-nodejs: https://github.com/bcoe/awesome-cross-platform-nodejs
- Vitest Documentation: https://vitest.dev/guide/features
- bundlephobia.com: https://bundlephobia.com
- Socket.dev - npm Trusted Publishing: https://socket.dev/blog/npm-trusted-publishing
- Open Source Initiative - Top Licenses 2025: https://opensource.org/blog/top-open-source-licenses-in-2025

### Tertiary (LOW confidence - marked for validation)
- Various Medium/DEV.to articles on npm best practices (2024-2026)
- Community comparisons of package managers (pnpm benchmarks)
- WebSearch results on quickstart best practices (general guidance, not npm-specific)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - semantic-release, vitest, and trusted publishing are well-documented official solutions
- Architecture: HIGH - patterns sourced from official npm docs and Node.js documentation
- Pitfalls: MEDIUM-HIGH - combination of official docs and verified community experiences; Windows testing is HIGH priority item
- Code examples: HIGH - all examples based on official documentation patterns
- State of the art: HIGH - trusted publishing GA date verified, semantic-release is measurably dominant

**Research date:** 2026-01-20
**Valid until:** ~30 days (February 2026) - npm ecosystem is stable; semantic-release and trusted publishing are mature standards. Vitest is rapidly evolving but API is stable.

**Areas requiring validation during planning:**
1. Windows cross-platform testing - HIGH priority, needs CI matrix
2. CLI wrapper necessity - user research needed
3. TypeScript definitions - assess user demand vs. effort
4. Example project scope - minimal viable example definition
