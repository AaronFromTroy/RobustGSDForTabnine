---
phase: 08-verification-and-quality-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - gsd/scripts/quality-checker.js
  - gsd/scripts/verifier.js
autonomous: true

must_haves:
  truths:
    - "Quality checker can enforce coverage thresholds (80% default)"
    - "Quality checker can run linting and report errors vs warnings"
    - "Verifier orchestrates multi-layer verification (smoke → lint → unit → integration → acceptance)"
    - "Verifier fails fast on critical issues (smoke tests, linting errors)"
    - "Verification results include duration and layer-by-layer status"
  artifacts:
    - path: "gsd/scripts/quality-checker.js"
      provides: "Quality gate enforcement for coverage and linting"
      exports: ["checkCoverageThreshold", "runLinting", "checkQualityGates"]
    - path: "gsd/scripts/verifier.js"
      provides: "Multi-layer verification orchestrator"
      exports: ["verifyPhase", "runSmokeTests", "runUnitTests", "runIntegrationTests"]
  key_links:
    - from: "gsd/scripts/verifier.js"
      to: "gsd/scripts/goal-validator.js"
      via: "validateAcceptanceCriteria import"
      pattern: "import.*validateAcceptanceCriteria.*goal-validator"
    - from: "gsd/scripts/verifier.js"
      to: "gsd/scripts/quality-checker.js"
      via: "checkQualityGates import"
      pattern: "import.*checkQualityGates.*quality-checker"
    - from: "gsd/scripts/quality-checker.js"
      to: "gsd/scripts/process-runner.js"
      via: "runCommand for test execution"
      pattern: "runCommand"
---

<objective>
Create quality gate enforcement and multi-layer verification orchestrator.

Purpose: Implement the 5-layer verification pattern from research (smoke → static → unit → integration → acceptance) with quality gates that enforce coverage thresholds, linting rules, and acceptance criteria. This enables the verify-work.md guideline to execute comprehensive verification beyond just artifact structure checks.

Output: quality-checker.js for coverage/linting validation and verifier.js for orchestrating all verification layers in sequence with fail-fast behavior on critical issues.
</objective>

<execution_context>
@C:/Users/acous/OneDrive/Documents/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/acous/OneDrive/Documents/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Projects/GSDForTabnine/.planning/PROJECT.md
@C:/Projects/GSDForTabnine/.planning/ROADMAP.md
@C:/Projects/GSDForTabnine/.planning/STATE.md
@C:/Projects/GSDForTabnine/.planning/phases/08-verification-and-quality-system/08-RESEARCH.md
@C:/Projects/GSDForTabnine/gsd/guidelines/verify-work.md
@C:/Projects/GSDForTabnine/gsd/scripts/validator.js
@C:/Projects/GSDForTabnine/gsd/scripts/integration-test.js
@C:/Projects/GSDForTabnine/gsd/scripts/process-runner.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quality-checker.js module</name>
  <files>gsd/scripts/quality-checker.js</files>
  <action>
    Create quality-checker.js module for quality gate enforcement (research lines 163-194, 409-435).

    Exports (3 functions, 180-220 lines total):

    1. checkCoverageThreshold(coverageData, threshold = 80):
       - Accepts coverage object: { lines, branches, functions, statements }
       - Compares each metric against threshold (default 80%)
       - Returns { passed, failures: [...] }
       - Failures array: "Lines coverage 75% below 80% threshold", "Branches coverage 70% below 80%"
       - Pattern: all metrics must meet threshold for passed=true

    2. runLinting(options = {}):
       - Executes ESLint via runCommand('npx', ['eslint', '.'])
       - Parses output for error count and warning count
       - Returns { passed, errors, warnings, output }
       - passed: true if exitCode === 0 (no errors; warnings allowed)
       - Parsing: /(\d+) error/, /(\d+) warning/ regex patterns
       - Handle case where eslint not installed: return { passed: true, errors: 0, warnings: 0, output: 'ESLint not configured' }

    3. checkQualityGates(results, gates = DEFAULT_GATES):
       - Accepts results object: { coverage, testFailures, lintingErrors, complexity }
       - Accepts gates config: { coverage: {threshold: 80}, tests: {allowFailures: 0}, linting: {allowErrors: 0, allowWarnings: true} }
       - Checks each gate, accumulates failures
       - Returns { passed, failures: [...], status: 'PASS'|'FAIL' }
       - Example failure: "Coverage 75% below 80% threshold"

    DEFAULT_GATES constant:
    ```javascript
    const DEFAULT_GATES = {
      coverage: { threshold: 80, metric: 'lines' },
      tests: { allowFailures: 0 },
      linting: { allowErrors: 0, allowWarnings: true }
    };
    ```

    Import patterns:
    - runCommand from './process-runner.js'

    Parsing helpers (internal functions):
    - parseErrorCount(output): extract "X error" from ESLint output
    - parseWarningCount(output): extract "X warning" from ESLint output
    - parseCoverage(output): extract coverage percentage from test output (pattern: /All files\s+\|\s+([\d.]+)/)

    Error handling:
    - If eslint command fails (not installed): don't fail quality gate, return passed=true with note
    - If test command fails: return passed=false with error message
    - Graceful handling of missing data: if coverage object missing fields, assume 0%

    Follow existing module patterns:
    - JSDoc comments for all exported functions
    - Clear parameter types and return values
    - Specific error messages with context
  </action>
  <verify>
    1. Module exports 3 functions: checkCoverageThreshold, runLinting, checkQualityGates
    2. checkCoverageThreshold compares coverage metrics against threshold
    3. runLinting executes ESLint and parses errors/warnings
    4. checkQualityGates accumulates failures across multiple gate types
    5. DEFAULT_GATES constant defines default thresholds
    6. Code follows ESM syntax (import/export)
    7. All functions have JSDoc comments
    8. No syntax errors (can be imported without throwing)
  </verify>
  <done>
    quality-checker.js module exists and implements quality gate enforcement. Module can check coverage thresholds, run linting, and validate multiple quality gates with configurable thresholds. Provides the quality enforcement layer needed by multi-layer verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create verifier.js orchestrator</name>
  <files>gsd/scripts/verifier.js</files>
  <action>
    Create verifier.js module for multi-layer verification orchestration (research lines 571-738).

    Exports (5 functions, 350-400 lines total):

    1. verifyPhase(phaseNumber, options = {}):
       - Main orchestrator: runs all 5 verification layers in sequence
       - Layers: smoke → lint → unit → integration → acceptance
       - Fail fast: stops on critical issues (smoke failed, lint errors)
       - Returns { phase, passed, layers: {}, failures: [], duration }
       - Options: { coverageThreshold: 80 } (configurable threshold)
       - Pattern from research: log progress ("Layer 1/5: Running smoke tests..."), accumulate results

    2. runSmokeTests(phaseNumber):
       - Quick sanity checks (10 seconds max):
         * checkStateFileValid(): STATE.md exists and has valid structure
         * checkPhaseDirectoryExists(phaseNumber): .planning/phases/NN-* exists
         * checkRequiredFilesExist(): PROJECT.md, ROADMAP.md, REQUIREMENTS.md exist
       - Returns { passed, duration: '10s', checks: [...] }
       - All checks must pass for passed=true

    3. runUnitTests():
       - Executes integration-test.js (GSD system doesn't have separate unit tests per research open question 2)
       - Command: runCommand('node', ['gsd/scripts/integration-test.js'])
       - Parses output for test count and coverage
       - Returns { passed, count, coverage, output }
       - Coverage parsing: /(\d+) tests passed.*coverage: (\d+)%/ (approximate pattern)

    4. runIntegrationTests():
       - Currently same as runUnitTests (GSD uses integration-test.js for both)
       - Returns { passed, count, failures, output }
       - Failures parsing: /(\d+) failed/ regex pattern
       - Note in code comment: "GSD uses integration-test.js for both unit and integration tests per current architecture"

    5. finalizeResults(results, startTime):
       - Calculates duration: (Date.now() - startTime) / 1000 (seconds)
       - Sets results.passed based on failures.length === 0
       - Returns completed results object

    Internal workflow (verifyPhase function):
    ```javascript
    const startTime = Date.now();
    const results = { phase, passed: false, layers: {}, failures: [], duration: 0 };

    // Layer 1: Smoke tests (fail fast)
    results.layers.smoke = await runSmokeTests(phaseNumber);
    if (!results.layers.smoke.passed) {
      results.failures.push('Smoke tests failed - build is unstable');
      return finalizeResults(results, startTime);
    }

    // Layer 2: Static analysis (fail fast on errors)
    results.layers.linting = await runLinting();
    if (results.layers.linting.errors > 0) {
      results.failures.push(`${results.layers.linting.errors} linting error(s) found`);
      return finalizeResults(results, startTime);
    }

    // Layer 3: Unit tests with coverage (accumulate, don't fail fast)
    results.layers.unitTests = await runUnitTests();
    if (results.layers.unitTests.coverage < options.coverageThreshold || 80) {
      results.failures.push(`Coverage ${results.layers.unitTests.coverage}% below ${threshold}%`);
    }

    // Layer 4: Integration tests (accumulate)
    results.layers.integration = await runIntegrationTests();
    if (results.layers.integration.failures > 0) {
      results.failures.push(`${results.layers.integration.failures} integration test(s) failed`);
    }

    // Layer 5: Acceptance criteria (accumulate)
    results.layers.acceptance = await validateAcceptanceCriteria(phaseNumber);
    const failedCriteria = results.layers.acceptance.filter(c => !c.passed);
    if (failedCriteria.length > 0) {
      results.failures.push(`${failedCriteria.length} acceptance criterion/criteria not met`);
    }

    return finalizeResults(results, startTime);
    ```

    Import patterns:
    - validateAcceptanceCriteria from './goal-validator.js'
    - runLinting from './quality-checker.js'
    - runCommand from './process-runner.js'
    - readFile, fileExists from './file-ops.js'
    - path from 'node:path'

    Smoke test checks (checkStateFileValid, checkPhaseDirectoryExists, checkRequiredFilesExist):
    - Use fileExists to check file presence
    - Don't validate content deeply (that's for other layers)
    - Just verify critical files exist and are readable

    Parsing helpers (internal functions):
    - parseTestCount(output): extract test count from integration-test.js output
    - parseFailureCount(output): extract failure count
    - parseCoverage(output): extract coverage percentage

    Error handling:
    - Wrap each layer in try-catch: if layer throws, add to failures and continue (except smoke/lint which fail fast)
    - Log layer progress to console for monitoring

    Follow existing patterns:
    - JSDoc comments for all exported functions
    - Clear separation of concerns (each layer is isolated function)
    - Explicit return values with consistent structure
  </action>
  <verify>
    1. Module exports 5 functions: verifyPhase, runSmokeTests, runUnitTests, runIntegrationTests, finalizeResults
    2. verifyPhase orchestrates all 5 layers in sequence
    3. runSmokeTests checks STATE.md, phase directory, required files
    4. runUnitTests and runIntegrationTests execute integration-test.js
    5. Fail-fast behavior on smoke tests and linting errors
    6. Coverage threshold checking integrated
    7. validateAcceptanceCriteria imported from goal-validator.js
    8. Code follows ESM syntax (import/export)
    9. All functions have JSDoc comments
    10. No syntax errors (can be imported without throwing)
  </verify>
  <done>
    verifier.js module exists and implements multi-layer verification orchestration. Module runs 5 verification layers (smoke → lint → unit → integration → acceptance) with fail-fast on critical issues and comprehensive results reporting. This is the main entry point for phase verification that verify-work.md guideline will invoke.
  </done>
</task>

</tasks>

<verification>
Run these checks after task completion:

1. Quality checker module import:
   ```bash
   node -e "import('./gsd/scripts/quality-checker.js').then(m => console.log('Exports:', Object.keys(m)))"
   ```
   Expected: Exports: checkCoverageThreshold, runLinting, checkQualityGates

2. Verifier module import:
   ```bash
   node -e "import('./gsd/scripts/verifier.js').then(m => console.log('Exports:', Object.keys(m)))"
   ```
   Expected: Exports: verifyPhase, runSmokeTests, runUnitTests, runIntegrationTests, finalizeResults

3. Check coverage threshold logic:
   ```bash
   node -e "import('./gsd/scripts/quality-checker.js').then(m => { const result = m.checkCoverageThreshold({lines: 75, branches: 80, functions: 85}, 80); console.log('Passed:', result.passed, 'Failures:', result.failures.length); })"
   ```
   Expected: Passed: false, Failures: 1 (lines below threshold)

4. Run smoke tests:
   ```bash
   node -e "import('./gsd/scripts/verifier.js').then(async m => { const result = await m.runSmokeTests(1); console.log('Smoke tests passed:', result.passed); })"
   ```
   Expected: Smoke tests passed: true (Phase 1 exists and STATE.md is valid)

5. Full phase verification (Phase 1):
   ```bash
   node -e "import('./gsd/scripts/verifier.js').then(async m => { const result = await m.verifyPhase(1); console.log('Verification:', result.passed ? 'PASSED' : 'FAILED', 'Failures:', result.failures.length); })"
   ```
   Expected: Verification result with layer-by-layer status
</verification>

<success_criteria>
1. quality-checker.js exports 3 functions for quality gate enforcement
2. checkCoverageThreshold compares metrics against configurable thresholds
3. runLinting executes ESLint and parses errors/warnings correctly
4. checkQualityGates validates multiple gate types with failure accumulation
5. verifier.js exports 5 functions for multi-layer verification
6. verifyPhase orchestrates all 5 layers with fail-fast on critical issues
7. runSmokeTests validates critical files exist (STATE.md, phase directory, artifacts)
8. runUnitTests and runIntegrationTests execute existing integration-test.js
9. Acceptance criteria validation integrated via goal-validator.js import
10. Duration tracking and comprehensive results reporting implemented
11. All modules follow ESM syntax and GSD patterns (error handling, JSDoc)
12. No import/syntax errors (can be imported and used immediately)
</success_criteria>

<output>
After completion, create `.planning/phases/08-verification-and-quality-system/08-02-SUMMARY.md`
</output>
