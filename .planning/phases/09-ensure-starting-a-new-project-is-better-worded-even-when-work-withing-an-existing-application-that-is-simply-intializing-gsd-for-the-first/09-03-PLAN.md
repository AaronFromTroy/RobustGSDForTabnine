---
phase: 09-ensure-starting-a-new-project-is-better-worded-even-when-work-withing-an-existing-application-that-is-simply-intializing-gsd-for-the-first
plan: 03
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - gsd/guidelines/new-project.md
autonomous: true

must_haves:
  truths:
    - "Workflow asks 'what you want to accomplish' instead of 'project name and value'"
    - "Workflow detects if directory contains existing code"
    - "Workflow branches based on existing vs new project detection"
    - "For existing projects, codebase research happens before requirements generation"
  artifacts:
    - path: "gsd/guidelines/new-project.md"
      provides: "Goal-oriented initialization workflow"
      contains: "what you want to accomplish"
      min_lines: 180
    - path: "gsd/guidelines/new-project.md"
      provides: "Existing project detection logic"
      contains: "detect existing code"
  key_links:
    - from: "new-project.md workflow steps"
      to: "codebase-detector.js"
      via: "detection step before artifact generation"
      pattern: "node gsd/scripts/codebase-detector.js"
---

<objective>
Update new-project.md guideline to be goal-oriented (ask what user wants to accomplish), detect existing codebases, and branch the workflow to include codebase research for existing projects.

Purpose: The current workflow assumes blank-slate projects and asks for metadata (name/value) instead of user goals. This creates misalignment where GSD generates requirements blindly without understanding existing code, architecture, or patterns. Goal-oriented questioning + existing project detection + research step ensures context-aware initialization.

Output: Updated new-project.md guideline that:
1. Asks goal-oriented questions ("what do you want to accomplish?")
2. Detects existing code in current directory
3. Branches workflow (new project → simple init, existing project → research-first init)
4. Integrates codebase research before requirements generation
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.planning\phases\09-ensure-starting-a-new-project-is-better-worded-even-when-work-withing-an-existing-application-that-is-simply-intializing-gsd-for-the-first\09-RESEARCH.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\gsd\guidelines\new-project.md
@C:\Projects\GSDForTabnine\.planning\phases\09-ensure-starting-a-new-project-is-better-worded-even-when-work-withing-an-existing-application-that-is-simply-intializing-gsd-for-the-first\09-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Change questioning approach in Workflow Steps section</name>
  <files>gsd/guidelines/new-project.md</files>
  <action>
    Update the "Workflow Steps" section (starting around line 128) to change the questioning approach:

    **Current Step 1:**
    ```
    1. **Detect trigger phrase:**
       - User says "start GSD" or equivalent trigger from `.gsd-config.json`
       - Confirm project name and core value with user
    ```

    **Replace with:**
    ```
    1. **Detect trigger phrase and gather context:**
       - User says "start GSD" or equivalent trigger from `.gsd-config.json`
       - Ask: "What do you want to accomplish with this project?"
       - Listen for goals, features, problems to solve (not metadata like project name)
       - Extract project name from directory name or ask if ambiguous
       - Derive core value from user's stated goals
    ```

    WHY goal-oriented: Research shows asking for metadata (name/value) frontloads abstract thinking. Users know what they want to build, not necessarily how to articulate "core value". Asking goals → deriving value → confirming with user is more natural and produces better alignment.

    WHY derive from directory: Most projects already have a directory name. Asking again creates friction. Use directory name as default, ask only if it's generic (like "project" or "app").

    Also update the "Next Action" section (line ~172) to reflect this change:
    ```
    After successful completion:
    - Inform user: "GSD initialized for [PROJECT_NAME]. Your goal: [USER_STATED_GOAL]. Next: I'll help define requirements based on this goal."
    - Recommended workflow: System generates initial REQUIREMENTS.md based on user's stated goals, then user reviews/refines
    ```
  </action>
  <verify>
    ```bash
    grep -n "What do you want to accomplish" gsd/guidelines/new-project.md
    grep -n "Extract project name from directory" gsd/guidelines/new-project.md
    grep -n "Derive core value from user's stated goals" gsd/guidelines/new-project.md
    ```
    All 3 patterns should appear in the updated workflow steps.
  </verify>
  <done>
    new-project.md Workflow Steps ask goal-oriented questions and derive metadata from user goals and directory context.
  </done>
</task>

<task type="auto">
  <name>Add existing project detection step</name>
  <files>gsd/guidelines/new-project.md</files>
  <action>
    Insert a new step 2 in "Workflow Steps" section (after the updated step 1, before "Create planning directory"):

    ```
    2. **Detect existing codebase:**
       - Execute: `node gsd/scripts/codebase-detector.js`
       - Script checks for indicators of existing project:
         * package.json, requirements.txt, Cargo.toml (dependency files)
         * src/, app/, lib/ directories (common code directories)
         * More than just .git/ and gsd/ in current directory
       - Output: { isExisting: true/false, indicators: [...] }
       - Store detection result in workflow context for branching logic
    ```

    Then update the numbering of subsequent steps (old step 2 "Create planning directory" becomes step 3, etc.).

    Add a new section before "Commands" (around line 13) called "## Workflow Branching":

    ```markdown
    ## Workflow Branching

    This workflow adapts based on whether the current directory contains existing code:

    **New Project (empty or only .git/):**
    - Simple initialization flow
    - User provides goals → generate PROJECT.md and REQUIREMENTS.md
    - Proceed to next workflow

    **Existing Project (contains code, dependencies, structure):**
    - Research-first initialization flow
    - Detect existing codebase → analyze tech stack, architecture, patterns
    - Generate codebase research summary (CODEBASE.md in .planning/)
    - User provides goals → generate context-aware PROJECT.md and REQUIREMENTS.md
    - Requirements consider existing patterns and constraints
    ```

    WHY branching matters: Existing projects have tech choices already made, patterns already established, constraints already in place. Blindly generating requirements ignores this context and creates misalignment. Research-first initialization respects existing decisions.

    WHY separate section: Makes branching logic explicit and findable. Executor can quickly see "there are two paths" without parsing prose.
  </action>
  <verify>
    ```bash
    grep -n "Detect existing codebase" gsd/guidelines/new-project.md
    grep -n "node gsd/scripts/codebase-detector.js" gsd/guidelines/new-project.md
    grep -n "## Workflow Branching" gsd/guidelines/new-project.md
    grep -n "Existing Project (contains code" gsd/guidelines/new-project.md
    ```
    All patterns should appear, and "Workflow Branching" section should exist before Commands section.
  </verify>
  <done>
    new-project.md includes codebase detection step and explicit branching logic section showing two initialization paths.
  </done>
</task>

<task type="auto">
  <name>Integrate codebase research for existing projects</name>
  <files>gsd/guidelines/new-project.md</files>
  <action>
    Add a new step after "Detect existing codebase" (new step 3) for existing project path:

    ```
    3. **Perform codebase research (if existing project):**
       - **ONLY execute if step 2 detected isExisting: true**
       - Execute: `node gsd/scripts/codebase-researcher.js --output=.planning/CODEBASE.md`
       - Script analyzes:
         * Tech stack (languages, frameworks, libraries from package files)
         * Directory structure and architecture patterns
         * Coding conventions (linting configs, formatting)
         * Existing tests and quality infrastructure
       - Output: `.planning/CODEBASE.md` with structured findings
       - Pass CODEBASE.md context to template-renderer.js when generating PROJECT.md
       - Use findings to inform REQUIREMENTS.md generation (respect existing patterns)

       **If new project (isExisting: false), skip this step entirely.**
    ```

    Update the "Commands" section to show conditional execution:

    ```bash
    # Detect existing codebase
    node gsd/scripts/codebase-detector.js > .planning/.codebase-detection.json

    # Conditional: Research existing codebase (only if detected as existing)
    # Check .codebase-detection.json for isExisting flag
    # If true, execute:
    #   node gsd/scripts/codebase-researcher.js --output=.planning/CODEBASE.md

    # Create planning directory (if doesn't exist)
    mkdir -p .planning

    # Generate PROJECT.md (pass CODEBASE.md if exists)
    node gsd/scripts/template-renderer.js --template=PROJECT --output=.planning/PROJECT.md --projectName="${PROJECT_NAME}" --createdDate="${DATE}" --coreValue="${CORE_VALUE}" --existingCodebase=".planning/CODEBASE.md"

    # ... (rest of commands remain the same)
    ```

    WHY conditional execution: New projects don't need research (nothing to research). Existing projects MUST have research to avoid generating blind requirements that conflict with existing architecture.

    WHY pass to template-renderer: PROJECT.md should reference existing tech choices. REQUIREMENTS.md should build on existing patterns. Template renderer needs this context to generate aligned artifacts.

    Update the "Testing" section to include CODEBASE.md validation for existing projects:

    ```
    5. (If existing project) `.planning/CODEBASE.md` exists and contains:
       - Tech Stack section
       - Architecture Patterns section
       - Conventions section
    ```
  </action>
  <verify>
    ```bash
    grep -n "Perform codebase research (if existing project)" gsd/guidelines/new-project.md
    grep -n "codebase-researcher.js" gsd/guidelines/new-project.md
    grep -n "ONLY execute if step 2 detected isExisting: true" gsd/guidelines/new-project.md
    grep -n "existingCodebase=" gsd/guidelines/new-project.md
    ```
    All patterns should appear, showing conditional research step and integration with template rendering.
  </verify>
  <done>
    new-project.md includes codebase research step for existing projects, conditional execution logic, and integration with artifact generation.
  </done>
</task>

</tasks>

<verification>
Verify new-project.md guideline updates are complete and coherent:

```bash
# Verify all new patterns exist
grep -n "What do you want to accomplish" gsd/guidelines/new-project.md
grep -n "Detect existing codebase" gsd/guidelines/new-project.md
grep -n "Perform codebase research" gsd/guidelines/new-project.md
grep -n "## Workflow Branching" gsd/guidelines/new-project.md

# Verify guideline is still valid markdown
npx markdownlint gsd/guidelines/new-project.md

# Verify frontmatter still intact
head -7 gsd/guidelines/new-project.md | grep "workflow: \"new-project\""

# Verify success criteria still exists
tail -20 gsd/guidelines/new-project.md | grep "Success Criteria"
```

The guideline should:
- Ask goal-oriented questions upfront
- Include codebase detection step
- Branch workflow based on detection
- Integrate research for existing projects
- Maintain all original structure (frontmatter, sections, success criteria)
- Reference scripts that will be created in plan 09-04
</verification>

<success_criteria>
1. new-project.md asks "what do you want to accomplish" instead of asking for project name/value upfront
2. Workflow includes codebase detection step (node gsd/scripts/codebase-detector.js)
3. "Workflow Branching" section exists explaining new vs existing project paths
4. Research step integrated for existing projects with conditional execution
5. Commands section shows conditional execution based on detection
6. Testing section includes CODEBASE.md validation for existing projects
7. Guideline markdown is valid (passes markdownlint)
8. All original sections maintained (frontmatter, success criteria, boundaries)
</success_criteria>

<output>
After completion, create `.planning/phases/09-ensure-starting-a-new-project-is-better-worded-even-when-work-withing-an-existing-application-that-is-simply-intializing-gsd-for-the-first/09-03-SUMMARY.md`
</output>
