---
phase: 11-upgrade-system
plan: 03
type: execute
wave: 2
depends_on: [11-01, 11-02]
files_modified:
  - gsd/scripts/file-merger.js
  - gsd/scripts/migration-runner.js
  - gsd/scripts/migrations/migrations.json
  - gsd/package.json
autonomous: true

must_haves:
  truths:
    - System preserves user .gsd-config.json customizations during upgrade
    - System overwrites templates/, guidelines/, scripts/ (not user-editable)
    - System executes version-specific migration scripts in order
    - Migrations only run for versions between current and target
    - Migration failures stop upgrade process with clear error
  artifacts:
    - path: gsd/scripts/file-merger.js
      provides: File merge strategies
      exports: [mergeConfig, determineFileStrategy, applyUpgrade]
      min_lines: 100
    - path: gsd/scripts/migration-runner.js
      provides: Migration execution
      exports: [runMigrations, getApplicableMigrations]
      min_lines: 80
    - path: gsd/scripts/migrations/migrations.json
      provides: Migration registry
      contains: version
    - path: gsd/package.json
      provides: Updated dependencies
      contains: json-merge-patch
  key_links:
    - from: gsd/scripts/file-merger.js
      to: .gsd-config.json
      via: deep merge
      pattern: "merge.*config"
    - from: gsd/scripts/migration-runner.js
      to: migrations.json
      via: readFileSync
      pattern: "readFileSync.*migrations"
---

<objective>
Implement file merge strategies and migration infrastructure for safe upgrades.

Purpose: Enable upgrades that preserve user customizations while updating GSD core files. Support breaking changes through automated migration scripts.

Output: File merger module, migration runner, and migration registry following Nx/Angular patterns.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.claude\get-shit-done\workflows\execute-plan.md
@C:\Projects\GSDForTabnine\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-RESEARCH.md

# Dependencies from Wave 1
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-01-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-02-PLAN.md

# Existing infrastructure
@C:\Projects\GSDForTabnine\gsd\package.json
@C:\Projects\GSDForTabnine\gsd\.gsd-config.json
@C:\Projects\GSDForTabnine\gsd\scripts\file-ops.js
@C:\Projects\GSDForTabnine\gsd\scripts\validator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install merge dependency</name>
  <files>gsd/package.json, gsd/package-lock.json</files>
  <action>
Install json-merge-patch for deep merging configuration files.

Run from gsd/ directory:
```bash
cd "C:\Projects\GSDForTabnine\gsd"
npm install json-merge-patch@^1.0.2
```

json-merge-patch provides:
- Deep merge of nested JSON objects
- Preserves user customizations during merge
- Handles null values and conflicts correctly
- RFC 7396 standard implementation

Verify installation:
```bash
node -e "import('json-merge-patch').then(m => console.log('merge:', typeof m.merge))"
```
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
node -e "
import('json-merge-patch').then(({ merge }) => {
  const base = { a: 1, b: 2 };
  const user = { b: 3, c: 4 };
  const merged = merge(base, user);
  console.log('Merged:', merged); // Should be { a: 1, b: 3, c: 4 }
});
"
grep "json-merge-patch" package.json
```
  </verify>
  <done>json-merge-patch installed, merge function works, package.json updated</done>
</task>

<task type="auto">
  <name>Task 2: Create file-merger.js module</name>
  <files>gsd/scripts/file-merger.js</files>
  <action>
Create gsd/scripts/file-merger.js with three exported functions for file merge strategies.

Implementation requirements:

**Function 1: determineFileStrategy(filePath)**
- Returns merge strategy for given file path
- Strategy types: 'PRESERVE', 'OVERWRITE', 'MERGE'
- Rules:
  - PRESERVE: ['.gsd-config.json'] (user-customizable)
  - OVERWRITE: ['templates/', 'guidelines/', 'scripts/', 'package.json', 'README.md', 'QUICKSTART.md']
  - MERGE: [] (future: if users can customize templates)
- Returns strategy string
- Uses path matching (not exact string comparison)

**Function 2: mergeConfig(basePath, userPath, newPath, outputPath)**
- Deep merges configuration files preserving user customizations
- basePath: original version from backup (for three-way merge reference)
- userPath: user's current config
- newPath: new version from package
- Strategy: Start with new config, overlay user changes
- Uses json-merge-patch.merge() for deep merge
- Validates merged config using validator.js (JSON Schema)
- Writes result to outputPath
- Returns { merged: object, userChanges: string[] } showing what was preserved
- Throws error if merged config invalid

**Function 3: applyUpgrade(sourceDir, targetDir, backupPath, options = {})**
- Applies upgrade from sourceDir to targetDir
- For each file in sourceDir:
  - Determine strategy using determineFileStrategy()
  - PRESERVE: Skip file (keep user's version)
  - OVERWRITE: Copy from sourceDir to targetDir
  - MERGE: Call mergeConfig() with three-way merge
- Excludes node_modules/ from copy
- Uses fs-extra.copy() for file operations
- Logs each file operation for transparency
- Returns { filesUpdated: number, filesPreserved: number, filesMerged: number }

**File Strategy Constants:**
```javascript
const FILE_STRATEGIES = {
  PRESERVE: ['.gsd-config.json'],
  OVERWRITE: ['templates/', 'guidelines/', 'scripts/', 'package.json', 'README.md', 'QUICKSTART.md', 'LICENSE'],
  MERGE: [] // Future: user-customizable templates
};
```

**DO NOT:**
- Overwrite .gsd-config.json blindly (user loses customizations)
- Merge templates/ or guidelines/ (not user-editable)
- Copy node_modules/ (too large, run npm install after)

Use RESEARCH.md "Three-Way Config Merge" pattern as reference.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine"
# Manual test
node -e "
import('./gsd/scripts/file-merger.js').then(async (m) => {
  // Test 1: Determine strategy
  console.log('.gsd-config.json:', m.determineFileStrategy('.gsd-config.json')); // PRESERVE
  console.log('templates/PROJECT.md:', m.determineFileStrategy('templates/PROJECT.md')); // OVERWRITE
  console.log('scripts/state-manager.js:', m.determineFileStrategy('scripts/state-manager.js')); // OVERWRITE

  // Test 2: Merge config (create test files)
  import fs from 'fs';
  const base = { version: '1.0.0', paths: { planning: '.planning' } };
  const user = { version: '1.0.0', paths: { planning: '.planning' }, triggerPhrases: { start: ['custom trigger'] } };
  const latest = { version: '1.1.0', paths: { planning: '.planning', newPath: 'new' } };

  await fs.promises.writeFile('test-base.json', JSON.stringify(base));
  await fs.promises.writeFile('test-user.json', JSON.stringify(user));
  await fs.promises.writeFile('test-latest.json', JSON.stringify(latest));

  const result = await m.mergeConfig('test-base.json', 'test-user.json', 'test-latest.json', 'test-merged.json');
  console.log('Merged config:', result);

  await fs.promises.unlink('test-base.json');
  await fs.promises.unlink('test-user.json');
  await fs.promises.unlink('test-latest.json');
  await fs.promises.unlink('test-merged.json');

  console.log('‚úÖ File merger works');
});
"
```

Expected: Correct strategies returned, config merge preserves user changes.
  </verify>
  <done>file-merger.js exports 3 functions, strategy detection works, config merge preserves customizations</done>
</task>

<task type="auto">
  <name>Task 3: Create migration infrastructure</name>
  <files>gsd/scripts/migration-runner.js, gsd/scripts/migrations/migrations.json</files>
  <action>
Create migration runner and registry following Nx/Angular pattern.

**Step 1: Create gsd/scripts/migrations/ directory**
```bash
mkdir -p "C:\Projects\GSDForTabnine\gsd\scripts\migrations"
```

**Step 2: Create gsd/scripts/migrations/migrations.json**
Registry format (Nx pattern):
```json
{
  "version": "2",
  "migrations": {}
}
```

Initial registry is empty - migrations added in future versions when breaking changes occur.

**Step 3: Create gsd/scripts/migration-runner.js**
Exports two functions:

**Function 1: getApplicableMigrations(fromVersion, toVersion)**
- Reads migrations.json registry
- Filters migrations where: semver.gt(migration.version, fromVersion) AND semver.lte(migration.version, toVersion)
- Sorts migrations by version (ascending) for sequential execution
- Returns array of migration objects: [{ id, version, description, implementation, type }]
- Handles empty registry gracefully (returns [])

**Function 2: runMigrations(fromVersion, toVersion, options = {})**
- Calls getApplicableMigrations() to get migration list
- For each migration:
  - Logs: "üîß [description] ([version])"
  - Dynamically imports migration.implementation file
  - Calls default export: await migrationFn.default()
  - On success: logs "   ‚úÖ Complete"
  - On failure: logs "   ‚ùå Failed: [error]", throws error to stop upgrade
- Returns { migrationsRun: number, results: array }
- Uses semver for version comparison (already installed in Wave 1)

**Migration script interface:**
Each migration exports default async function:
```javascript
// Example: gsd/scripts/migrations/1.0.0-to-1.1.0.js
export default async function migrate() {
  // Perform migration
  // Throw error on failure
}
```

**DO NOT:**
- Continue on migration failure (stop immediately)
- Skip migrations (must run all in sequence)
- Modify registry format (Nx pattern is battle-tested)

Use RESEARCH.md "Migration Script Execution (Nx Pattern)" as reference.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify directory created
ls scripts/migrations/

# Verify migrations.json
cat scripts/migrations/migrations.json

# Test migration-runner
node -e "
import('./scripts/migration-runner.js').then(async (m) => {
  // Test with empty registry
  const migrations = await m.getApplicableMigrations('1.0.0', '1.1.0');
  console.log('Applicable migrations:', migrations.length); // Should be 0

  const result = await m.runMigrations('1.0.0', '1.1.0');
  console.log('Migrations run:', result.migrationsRun); // Should be 0

  console.log('‚úÖ Migration runner works');
});
"
```

Expected: Directory exists, migrations.json valid, empty registry returns 0 migrations.
  </verify>
  <done>migration-runner.js exports 2 functions, migrations.json created, empty registry handled correctly</done>
</task>

<task type="auto">
  <name>Task 4: Add modules to exports</name>
  <files>gsd/package.json, gsd/scripts/index.js</files>
  <action>
Add file-merger and migration-runner to package.json exports and main entry.

1. Update gsd/package.json exports field:
```json
"exports": {
  ".": "./scripts/index.js",
  "./state-manager": "./scripts/state-manager.js",
  "./template-renderer": "./scripts/template-renderer.js",
  "./guideline-loader": "./scripts/guideline-loader.js",
  "./validator": "./scripts/validator.js",
  "./researcher": "./scripts/researcher.js",
  "./research-synthesizer": "./scripts/research-synthesizer.js",
  "./version-checker": "./scripts/version-checker.js",
  "./backup-manager": "./scripts/backup-manager.js",
  "./file-merger": "./scripts/file-merger.js",
  "./migration-runner": "./scripts/migration-runner.js"
}
```

2. Update gsd/scripts/index.js to re-export functions:
```javascript
// Add to existing exports
export { mergeConfig, determineFileStrategy, applyUpgrade } from './file-merger.js';
export { runMigrations, getApplicableMigrations } from './migration-runner.js';
```
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify file-merger export
node -e "import('./scripts/index.js').then((m) => {
  console.log('mergeConfig:', typeof m.mergeConfig);
  console.log('determineFileStrategy:', typeof m.determineFileStrategy);
  console.log('applyUpgrade:', typeof m.applyUpgrade);
})"

# Verify migration-runner export
node -e "import('./scripts/index.js').then((m) => {
  console.log('runMigrations:', typeof m.runMigrations);
  console.log('getApplicableMigrations:', typeof m.getApplicableMigrations);
})"
```

Expected: All five functions exported as "function".
  </verify>
  <done>file-merger and migration-runner subpath exports added, main entry re-exports all functions</done>
</task>

</tasks>

<verification>
**Module exports:**
- file-merger.js exports mergeConfig, determineFileStrategy, applyUpgrade
- migration-runner.js exports runMigrations, getApplicableMigrations
- Functions accessible via subpath imports
- Functions re-exported from main entry

**File merge strategies:**
- determineFileStrategy returns PRESERVE for .gsd-config.json
- determineFileStrategy returns OVERWRITE for templates/, guidelines/, scripts/
- mergeConfig performs three-way merge preserving user customizations
- applyUpgrade applies strategies correctly

**Migration infrastructure:**
- migrations.json registry created (empty initially)
- getApplicableMigrations filters by version range
- runMigrations executes in order, stops on failure
- Semver used for version comparison
</verification>

<success_criteria>
**Plan complete when:**
1. json-merge-patch dependency installed
2. file-merger.js exists with 3 exported functions
3. determineFileStrategy returns correct strategies
4. mergeConfig performs three-way merge preserving user changes
5. applyUpgrade applies file strategies correctly
6. migration-runner.js exists with 2 exported functions
7. migrations.json registry created
8. getApplicableMigrations filters migrations by version
9. runMigrations executes migrations in order
10. Modules exported via package.json and index.js
</success_criteria>

<output>
After completion, create `.planning/phases/11-upgrade-system/11-03-SUMMARY.md`
</output>
