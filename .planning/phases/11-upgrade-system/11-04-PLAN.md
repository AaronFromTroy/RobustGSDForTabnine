---
phase: 11-upgrade-system
plan: 04
type: execute
wave: 2
depends_on: [11-01, 11-02, 11-03]
files_modified:
  - gsd/scripts/upgrade-manager.js
  - gsd/scripts/trigger-detector.js
  - gsd/.gsd-config.json
autonomous: true

must_haves:
  truths:
    - User can run upgrade with dry-run preview before applying
    - Upgrade shows what files will be updated/preserved/merged
    - Upgrade auto-detects best source (npm or local)
    - Upgrade falls back to local if npm unavailable
    - Upgrade creates backup before applying changes
    - Upgrade runs migrations between versions
    - Failed upgrade rolls back to backup automatically
    - User can trigger upgrade via "upgrade GSD" phrase
    - User can manually specify upgrade source if needed
  artifacts:
    - path: gsd/scripts/upgrade-manager.js
      provides: Upgrade orchestration
      exports: [upgrade, previewUpgrade, detectLocalSource, downloadFromNpm, validateLocalSource]
      min_lines: 250
    - path: gsd/scripts/trigger-detector.js
      provides: Updated trigger detection
      contains: upgrade GSD
    - path: gsd/.gsd-config.json
      provides: Updated trigger phrases
      contains: upgrade
  key_links:
    - from: gsd/scripts/upgrade-manager.js
      to: version-checker
      via: import
      pattern: "import.*version-checker"
    - from: gsd/scripts/upgrade-manager.js
      to: backup-manager
      via: import
      pattern: "import.*backup-manager"
    - from: gsd/scripts/upgrade-manager.js
      to: file-merger
      via: import
      pattern: "import.*file-merger"
    - from: gsd/scripts/upgrade-manager.js
      to: migration-runner
      via: import
      pattern: "import.*migration-runner"
---

<objective>
Implement upgrade orchestrator that coordinates version checking, backup, merge, migration, and rollback.

Purpose: Provide complete upgrade workflow with safety nets (dry-run, backup, validation, rollback) and clear user feedback.

Output: Upgrade manager module and trigger phrase integration for seamless upgrade experience.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\workflows\execute-plan.md
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\templates\summary.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-RESEARCH.md

# Dependencies from Wave 1 and 2
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-01-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-02-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-03-PLAN.md

# Existing infrastructure
@C:\Projects\GSDForTabnine\gsd\scripts\trigger-detector.js
@C:\Projects\GSDForTabnine\gsd\.gsd-config.json
@C:\Projects\GSDForTabnine\gsd\scripts\workflow-orchestrator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upgrade-manager.js orchestrator</name>
  <files>gsd/scripts/upgrade-manager.js</files>
  <action>
Create gsd/scripts/upgrade-manager.js with five exported functions for dual-mode upgrade orchestration.

Implementation requirements:

**Function 1: detectLocalSource()**
- Checks common locations for local GSD upgrades
- Candidates: ../gsd-upgrade, ../gsd-latest, ../gsd-for-tabnine, process.env.GSD_UPGRADE_PATH
- Uses version-checker.isValidGsdSource() for validation
- Returns path string if found, null otherwise
- Silent operation (no console output)

**Function 2: downloadFromNpm(options = {})**
- Creates temp directory: .gsd-temp-${Date.now()}
- Runs: npm pack gsd-for-tabnine@latest
- Extracts tarball using tar command
- Returns path to extracted package/ directory
- Cleans up on failure (remove temp dir)
- Throws error with helpful message on failure

**Function 3: validateLocalSource(localPath)**
- Uses version-checker.isValidGsdSource() for validation
- Returns localPath if valid
- Throws error with structure requirements if invalid
- Error includes helpful message about required files/dirs

**Function 4: previewUpgrade(options = {})**
- Options: { source, localPath }
- Auto-detects source if not specified (see upgrade() logic)
- Checks for available updates using version-checker.checkForUpdates()
- If no update: returns { hasUpdate: false, current: version }
- If update available:
  - Determines files to update using file-merger.determineFileStrategy()
  - Gets applicable migrations using migration-runner.getApplicableMigrations()
  - Returns preview object:
    ```javascript
    {
      hasUpdate: true,
      current: '1.0.0',
      latest: '1.2.0',
      updateType: 'minor',
      filesUpdated: ['templates/', 'guidelines/', 'scripts/', 'package.json'],
      filesPreserved: ['.gsd-config.json'],
      filesMerged: [],
      migrations: [
        { version: '1.1.0', description: 'Update config format' },
        { version: '1.2.0', description: 'Add new workflow' }
      ]
    }
    ```
- Displays formatted preview:
  ```
  === Upgrade Preview ===
  From: 1.0.0 â†’ To: 1.2.0 (minor)

  Files to update:
    ğŸ“ templates/ (12 files)
    ğŸ“ guidelines/ (5 files)
    ğŸ“ scripts/ (25 files)
    ğŸ“ package.json

  Files to preserve:
    âœ… .gsd-config.json (your customizations)

  Migrations to run:
    ğŸ”§ Update config format (1.1.0)
    ğŸ”§ Add new workflow (1.2.0)
  ```

**Function 5: upgrade(options = {})**
- Options: { source, localPath, dryRun: false, force: false, version: 'latest' }
- Steps:
  1. **Smart Source Detection** (if source not specified):
     a. Log "ğŸ” Detecting upgrade source..."
     b. Check npm availability using version-checker.checkNpmAvailability()
     c. If npm available: source = 'npm', log "âœ… npm registry available"
     d. If npm unavailable:
        - Log "âš ï¸ npm registry unavailable: ${reason}"
        - Call detectLocalSource()
        - If local found: source = 'local', localPath = detected, log "âœ… Found local source"
        - If neither: throw error with helpful instructions
  2. **Validate Source Before Proceeding**:
     a. If source === 'npm': sourceDir = downloadFromNpm()
     b. If source === 'local': sourceDir = validateLocalSource(localPath)
     c. On error, try fallback:
        - If npm failed: try detectLocalSource() and use local
        - If local failed: re-throw (no more fallbacks)
  3. Preview upgrade using previewUpgrade({ source, localPath })
  4. If dryRun: display preview and return (no changes)
  5. If no update: log "Already on latest version" and return
  6. If !force: Display preview and await user confirmation (return if declined)
  7. Create backup using backup-manager.createBackup()
  8. Validate backup using backup-manager.validateBackup()
  9. Apply upgrade using file-merger.applyUpgrade(sourceDir, 'gsd', backupPath)
  10. Run migrations using migration-runner.runMigrations()
  11. Validate upgraded installation (check package.json, .gsd-config.json)
  12. Run npm install to update dependencies
  13. On success: log backup path, source used, prompt user to verify
  14. On failure: restore backup using backup-manager.restoreBackup(), re-throw error

**Error handling:**
- npm unavailable: Try local fallback automatically
- Local validation fails: Clear error with structure requirements
- Backup creation failure: stop upgrade, log error
- Backup validation failure: stop upgrade, log errors
- Merge failure: restore backup, log error
- Migration failure: restore backup, log error
- Validation failure: restore backup, log error
- No source available: Helpful error with manual download instructions

**Console output format:**
```
ğŸ” Detecting upgrade source...
âœ… npm registry available
ğŸ“¦ Downloading from npm...
```
Or:
```
ğŸ” Detecting upgrade source...
âš ï¸  npm registry unavailable: Network error
ğŸ” Checking for local upgrade sources...
âœ… Found local source: ../gsd-upgrade
ğŸ“ Using local source: ../gsd-upgrade
```

**DO NOT:**
- Auto-delete backups (user's decision after verification)
- Force upgrade without confirmation (unless --force flag)
- Continue on migration failure (unsafe)
- Fail silently if npm unavailable (try local fallback first)
- Use hard-coded paths (check multiple conventional locations)

Use RESEARCH.md "Upgrade Command with Dry-Run" and "Backup and Rollback" patterns as reference.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine"
# Manual test (dry-run only to avoid actual upgrade)
node -e "
import('./gsd/scripts/upgrade-manager.js').then(async (m) => {
  // Test 1: Detect local source
  console.log('Testing local source detection...');
  const localSrc = await m.detectLocalSource();
  console.log('Local source:', localSrc || 'not found');

  // Test 2: Preview upgrade (auto-detect)
  console.log('\nChecking for updates...');
  const preview = await m.previewUpgrade();
  console.log('Preview:', preview);

  // Test 3: Dry-run upgrade (auto-detect source)
  console.log('\nDry-run upgrade with auto-detection...');
  await m.upgrade({ dryRun: true });

  // Test 4: Explicit local mode (if current dir valid)
  console.log('\nDry-run upgrade with explicit local source...');
  await m.upgrade({ dryRun: true, source: 'local', localPath: './gsd' });

  console.log('âœ… Upgrade manager works');
});
"
```

Expected: Local detection works, preview shows update status, dry-run auto-detects source, explicit local mode works.
  </verify>
  <done>upgrade-manager.js exports 5 functions, auto-detection works, fallback logic works, dry-run shows changes, full upgrade orchestrates all steps with dual-mode support</done>
</task>

<task type="auto">
  <name>Task 2: Add upgrade trigger phrase</name>
  <files>gsd/.gsd-config.json, gsd/scripts/trigger-detector.js</files>
  <action>
Update trigger configuration and detection to support "upgrade GSD" phrase.

**Step 1: Update gsd/.gsd-config.json**
Add upgrade trigger phrases:
```json
{
  "$schema": "./config-schema.json",
  "version": "1.0.0",
  "triggerPhrases": {
    "start": [
      "start GSD",
      "begin GSD",
      "initialize GSD",
      "start getting stuff done"
    ],
    "continue": [
      "continue GSD workflow",
      "resume GSD",
      "continue workflow",
      "resume getting stuff done"
    ],
    "upgrade": [
      "upgrade GSD",
      "update GSD",
      "upgrade gsd-for-tabnine"
    ]
  },
  "paths": { ... },
  "workflows": { ... }
}
```

**Step 2: Update gsd/scripts/trigger-detector.js**
Add upgrade detection:
```javascript
// In detectTrigger function, add upgrade check
const upgradePhrases = config.triggerPhrases?.upgrade || [];
if (upgradePhrases.some(phrase => normalizedInput.includes(phrase.toLowerCase()))) {
  return { type: 'upgrade', matched: true, phrase: input };
}
```

Add confirmTrigger case for upgrade:
```javascript
// In confirmTrigger function, add upgrade case
case 'upgrade':
  return `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ”µ UPGRADE DETECTED                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Trigger: "${trigger.phrase}"
â•‘
â•‘  This will:
â•‘  - Check for available GSD updates
â•‘  - Show preview of changes
â•‘  - Create backup before upgrade
â•‘  - Preserve your .gsd-config.json
â•‘  - Update templates, guidelines, scripts
â•‘
â•‘  Type "yes" to continue or "no" to cancel
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `;
```

**Step 3: Update config-schema.json**
Add upgrade to schema:
```json
{
  "triggerPhrases": {
    "type": "object",
    "properties": {
      "start": { "type": "array", "items": { "type": "string" } },
      "continue": { "type": "array", "items": { "type": "string" } },
      "upgrade": { "type": "array", "items": { "type": "string" } }
    }
  }
}
```
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify config updated
grep -A 5 "upgrade" .gsd-config.json

# Test trigger detection
node -e "
import('./scripts/trigger-detector.js').then(async (m) => {
  const trigger = await m.detectTrigger('upgrade GSD');
  console.log('Trigger type:', trigger.type); // Should be 'upgrade'

  const confirmation = await m.confirmTrigger(trigger);
  console.log('Confirmation:', confirmation);

  console.log('âœ… Upgrade trigger works');
});
"
```

Expected: Config contains upgrade phrases, trigger detection returns 'upgrade' type.
  </verify>
  <done>.gsd-config.json updated with upgrade phrases, trigger-detector.js detects upgrade trigger, config-schema.json updated</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with workflow orchestrator</name>
  <files>gsd/scripts/workflow-orchestrator.js</files>
  <action>
Update workflow-orchestrator.js to handle upgrade workflow.

Add upgrade workflow case to startWorkflow function:
```javascript
// In startWorkflow function, add after existing cases
case 'upgrade':
  console.log('\n=== GSD Upgrade Workflow ===\n');

  // Import upgrade-manager
  const { upgrade, previewUpgrade } = await import('./upgrade-manager.js');

  // Show preview
  console.log('Checking for updates...\n');
  const preview = await previewUpgrade();

  if (!preview.hasUpdate) {
    console.log(`âœ… Already on latest version (${preview.current})`);
    return { workflow: 'upgrade', status: 'up-to-date' };
  }

  // Display preview
  console.log(`Update available: ${preview.current} â†’ ${preview.latest} (${preview.updateType})\n`);

  // Execute upgrade (with user confirmation)
  console.log('Starting upgrade...\n');
  await upgrade({ dryRun: false, force: false });

  console.log('\nâœ… Upgrade complete!');
  console.log('Verify everything works, then remove backup from .gsd-backups/\n');

  return { workflow: 'upgrade', status: 'complete' };
```

This integrates upgrade into existing workflow system, using same confirmation pattern as start/continue.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Test workflow orchestrator integration
node -e "
import('./scripts/workflow-orchestrator.js').then(async (m) => {
  // Simulate upgrade trigger
  const trigger = { type: 'upgrade', matched: true, phrase: 'upgrade GSD' };

  console.log('Testing upgrade workflow integration...');
  // Note: This will check for real updates but won't apply (network may fail gracefully)

  console.log('âœ… Workflow orchestrator integration works');
});
"
```

Expected: Workflow orchestrator has upgrade case, calls upgrade-manager functions.
  </verify>
  <done>workflow-orchestrator.js handles upgrade workflow, integrates with upgrade-manager, follows existing patterns</done>
</task>

<task type="auto">
  <name>Task 4: Add module to exports</name>
  <files>gsd/package.json, gsd/scripts/index.js</files>
  <action>
Add upgrade-manager to package.json exports and main entry.

1. Update gsd/package.json exports field:
```json
"exports": {
  ".": "./scripts/index.js",
  "./state-manager": "./scripts/state-manager.js",
  "./template-renderer": "./scripts/template-renderer.js",
  "./guideline-loader": "./scripts/guideline-loader.js",
  "./validator": "./scripts/validator.js",
  "./researcher": "./scripts/researcher.js",
  "./research-synthesizer": "./scripts/research-synthesizer.js",
  "./version-checker": "./scripts/version-checker.js",
  "./backup-manager": "./scripts/backup-manager.js",
  "./file-merger": "./scripts/file-merger.js",
  "./migration-runner": "./scripts/migration-runner.js",
  "./upgrade-manager": "./scripts/upgrade-manager.js"
}
```

2. Update gsd/scripts/index.js to re-export upgrade-manager functions:
```javascript
// Add to existing exports
export { upgrade, previewUpgrade } from './upgrade-manager.js';
```
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify export
node -e "import('./scripts/index.js').then((m) => {
  console.log('upgrade:', typeof m.upgrade);
  console.log('previewUpgrade:', typeof m.previewUpgrade);
})"
```

Expected: Both functions exported as "function".
  </verify>
  <done>upgrade-manager subpath export added, main entry re-exports functions</done>
</task>

</tasks>

<verification>
**Module exports:**
- upgrade-manager.js exports upgrade, previewUpgrade
- Functions accessible via subpath import
- Functions re-exported from main entry

**Upgrade workflow:**
- previewUpgrade checks version, shows changes, lists migrations
- upgrade orchestrates: backup â†’ merge â†’ migrate â†’ validate â†’ verify
- Dry-run shows changes without applying
- User confirmation required (unless --force)

**Trigger integration:**
- "upgrade GSD" added to .gsd-config.json
- trigger-detector.js detects upgrade trigger
- workflow-orchestrator.js handles upgrade workflow
- Follows existing GSD patterns

**Safety features:**
- Backup created before changes
- Backup validated before proceeding
- Rollback on failure
- User verification prompt after upgrade
</verification>

<success_criteria>
**Plan complete when:**
1. upgrade-manager.js exists with 5 exported functions
2. detectLocalSource checks multiple conventional locations
3. downloadFromNpm handles npm package download and extraction
4. validateLocalSource validates local upgrade sources
5. previewUpgrade shows update status and change preview
6. upgrade orchestrates complete workflow with auto-detection
7. Auto-detection tries npm first, falls back to local
8. Helpful errors when neither source available
9. Dry-run mode works (shows changes without applying)
10. Backup created before upgrade, validated before proceeding
11. Rollback on failure restores from backup
12. "upgrade GSD" trigger phrase added to .gsd-config.json
13. trigger-detector.js detects upgrade trigger
14. workflow-orchestrator.js handles upgrade workflow
15. Module exported via package.json and index.js
</success_criteria>

<output>
After completion, create `.planning/phases/11-upgrade-system/11-04-SUMMARY.md`
</output>
