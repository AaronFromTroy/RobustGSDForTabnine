---
phase: 11-upgrade-system
plan: 05
type: execute
wave: 3
depends_on: [11-01, 11-02, 11-03, 11-04]
files_modified:
  - gsd/scripts/integration-test.js
  - gsd/CHANGELOG.md
  - gsd/README.md
autonomous: true

must_haves:
  truths:
    - Upgrade system tested with integration tests
    - Tests cover both npm and local upgrade modes
    - Tests validate auto-detection and fallback logic
    - Users have clear upgrade instructions in README
    - CHANGELOG documents upgrade process
    - Tests validate version detection, backup, merge, migration
    - Documentation explains dry-run, rollback, and safety features
    - Documentation covers both npm and local upgrade workflows
  artifacts:
    - path: gsd/scripts/integration-test.js
      provides: Test Suite 17 for upgrade system
      contains: Test Suite 17
      min_lines: 2100
    - path: gsd/CHANGELOG.md
      provides: Upgrade documentation
      contains: Upgrading
    - path: gsd/README.md
      provides: Updated upgrade instructions
      contains: upgrade GSD
  key_links:
    - from: gsd/scripts/integration-test.js
      to: version-checker
      via: import
      pattern: "import.*version-checker"
    - from: gsd/scripts/integration-test.js
      to: backup-manager
      via: import
      pattern: "import.*backup-manager"
    - from: gsd/CHANGELOG.md
      to: upgrade-manager
      via: documentation
      pattern: "upgrade"
---

<objective>
Validate upgrade system with comprehensive tests and provide clear user documentation.

Purpose: Ensure upgrade system works reliably and users understand how to safely upgrade GSD. Complete Phase 11 with production-ready upgrade capability.

Output: Test Suite 17 with 12+ tests, CHANGELOG.md with upgrade guide, updated README.md.
</objective>

<execution_context>
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\workflows\execute-plan.md
@C:\Projects\GSDForTabnine\.claude\get-stuff-done\templates\summary.md
</execution_context>

<context>
@C:\Projects\GSDForTabnine\.planning\PROJECT.md
@C:\Projects\GSDForTabnine\.planning\ROADMAP.md
@C:\Projects\GSDForTabnine\.planning\STATE.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-RESEARCH.md

# Dependencies from Wave 1 and 2
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-01-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-02-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-03-PLAN.md
@C:\Projects\GSDForTabnine\.planning\phases\11-upgrade-system\11-04-PLAN.md

# Existing infrastructure
@C:\Projects\GSDForTabnine\gsd\scripts\integration-test.js
@C:\Projects\GSDForTabnine\gsd\README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Test Suite 17 to integration-test.js</name>
  <files>gsd/scripts/integration-test.js</files>
  <action>
Add Test Suite 17 to gsd/scripts/integration-test.js with 15 tests for dual-mode upgrade system validation.

Insert after Test Suite 16, before the "Run all tests" section:

```javascript
// =============================================================================
// TEST SUITE 17: Upgrade System (Phase 11)
// =============================================================================

async function testSuite17_UpgradeSystem() {
  const results = [];

  // Test 1: version-checker module exports
  try {
    const versionChecker = await import('./version-checker.js');
    assert(typeof versionChecker.checkForUpdates === 'function', 'checkForUpdates should be function');
    assert(typeof versionChecker.getCurrentVersion === 'function', 'getCurrentVersion should be function');
    assert(typeof versionChecker.getLatestVersion === 'function', 'getLatestVersion should be function');
    results.push({ test: 'version-checker exports', passed: true });
  } catch (error) {
    results.push({ test: 'version-checker exports', passed: false, error: error.message });
  }

  // Test 2: getCurrentVersion reads package.json
  try {
    const { getCurrentVersion } = await import('./version-checker.js');
    const version = await getCurrentVersion();
    assert(typeof version === 'string', 'getCurrentVersion should return string');
    assert(/^\d+\.\d+\.\d+/.test(version), 'Version should match semver format');
    results.push({ test: 'getCurrentVersion reads package.json', passed: true });
  } catch (error) {
    results.push({ test: 'getCurrentVersion reads package.json', passed: false, error: error.message });
  }

  // Test 3: checkNpmAvailability returns availability status
  try {
    const { checkNpmAvailability } = await import('./version-checker.js');
    const result = await checkNpmAvailability();
    assert(typeof result === 'object', 'checkNpmAvailability should return object');
    assert(typeof result.available === 'boolean', 'available should be boolean');
    results.push({ test: 'checkNpmAvailability structure', passed: true });
  } catch (error) {
    results.push({ test: 'checkNpmAvailability structure', passed: false, error: error.message });
  }

  // Test 4: isValidGsdSource validates GSD installations
  try {
    const { isValidGsdSource } = await import('./version-checker.js');
    const isValid = await isValidGsdSource('.');
    assert(typeof isValid === 'boolean', 'isValidGsdSource should return boolean');
    assert(isValid === true, 'Current directory should be valid GSD source');
    results.push({ test: 'isValidGsdSource validation', passed: true });
  } catch (error) {
    results.push({ test: 'isValidGsdSource validation', passed: false, error: error.message });
  }

  // Test 5: checkForUpdates returns correct structure
  try {
    const { checkForUpdates } = await import('./version-checker.js');
    const result = await checkForUpdates();
    assert(typeof result === 'object', 'checkForUpdates should return object');
    assert(typeof result.hasUpdate === 'boolean', 'hasUpdate should be boolean');
    assert(typeof result.current === 'string', 'current should be string');
    results.push({ test: 'checkForUpdates structure', passed: true });
  } catch (error) {
    results.push({ test: 'checkForUpdates structure', passed: false, error: error.message });
  }

  // Test 6: backup-manager module exports
  try {
    const backupManager = await import('./backup-manager.js');
    assert(typeof backupManager.createBackup === 'function', 'createBackup should be function');
    assert(typeof backupManager.restoreBackup === 'function', 'restoreBackup should be function');
    assert(typeof backupManager.listBackups === 'function', 'listBackups should be function');
    assert(typeof backupManager.validateBackup === 'function', 'validateBackup should be function');
    results.push({ test: 'backup-manager exports', passed: true });
  } catch (error) {
    results.push({ test: 'backup-manager exports', passed: false, error: error.message });
  }

  // Test 7: createBackup creates valid backup (offline test)
  try {
    const { createBackup, validateBackup } = await import('./backup-manager.js');
    // Note: This creates a real backup - cleanup after test
    const backup = await createBackup('gsd', { testMode: true });
    assert(typeof backup.backupPath === 'string', 'backupPath should be string');
    assert(backup.backupPath.includes('.gsd-backups'), 'Backup should be in .gsd-backups/');

    const validation = await validateBackup(backup.backupPath);
    assert(validation.valid === true, 'Backup should validate successfully');

    // Cleanup: remove test backup
    await import('fs-extra').then(fs => fs.remove(backup.backupPath));

    results.push({ test: 'createBackup creates valid backup', passed: true });
  } catch (error) {
    results.push({ test: 'createBackup creates valid backup', passed: false, error: error.message });
  }

  // Test 8: file-merger module exports
  try {
    const fileMerger = await import('./file-merger.js');
    assert(typeof fileMerger.mergeConfig === 'function', 'mergeConfig should be function');
    assert(typeof fileMerger.determineFileStrategy === 'function', 'determineFileStrategy should be function');
    assert(typeof fileMerger.applyUpgrade === 'function', 'applyUpgrade should be function');
    results.push({ test: 'file-merger exports', passed: true });
  } catch (error) {
    results.push({ test: 'file-merger exports', passed: false, error: error.message });
  }

  // Test 9: determineFileStrategy returns correct strategies
  try {
    const { determineFileStrategy } = await import('./file-merger.js');
    assert(determineFileStrategy('.gsd-config.json') === 'PRESERVE', '.gsd-config.json should PRESERVE');
    assert(determineFileStrategy('templates/PROJECT.md') === 'OVERWRITE', 'templates should OVERWRITE');
    assert(determineFileStrategy('scripts/state-manager.js') === 'OVERWRITE', 'scripts should OVERWRITE');
    results.push({ test: 'determineFileStrategy strategies', passed: true });
  } catch (error) {
    results.push({ test: 'determineFileStrategy strategies', passed: false, error: error.message });
  }

  // Test 10: migration-runner module exports
  try {
    const migrationRunner = await import('./migration-runner.js');
    assert(typeof migrationRunner.runMigrations === 'function', 'runMigrations should be function');
    assert(typeof migrationRunner.getApplicableMigrations === 'function', 'getApplicableMigrations should be function');
    results.push({ test: 'migration-runner exports', passed: true });
  } catch (error) {
    results.push({ test: 'migration-runner exports', passed: false, error: error.message });
  }

  // Test 11: getApplicableMigrations with empty registry
  try {
    const { getApplicableMigrations } = await import('./migration-runner.js');
    const migrations = await getApplicableMigrations('1.0.0', '1.1.0');
    assert(Array.isArray(migrations), 'getApplicableMigrations should return array');
    assert(migrations.length === 0, 'Empty registry should return 0 migrations');
    results.push({ test: 'getApplicableMigrations empty registry', passed: true });
  } catch (error) {
    results.push({ test: 'getApplicableMigrations empty registry', passed: false, error: error.message });
  }

  // Test 12: upgrade-manager module exports
  try {
    const upgradeManager = await import('./upgrade-manager.js');
    assert(typeof upgradeManager.upgrade === 'function', 'upgrade should be function');
    assert(typeof upgradeManager.previewUpgrade === 'function', 'previewUpgrade should be function');
    assert(typeof upgradeManager.detectLocalSource === 'function', 'detectLocalSource should be function');
    assert(typeof upgradeManager.downloadFromNpm === 'function', 'downloadFromNpm should be function');
    assert(typeof upgradeManager.validateLocalSource === 'function', 'validateLocalSource should be function');
    results.push({ test: 'upgrade-manager exports', passed: true });
  } catch (error) {
    results.push({ test: 'upgrade-manager exports', passed: false, error: error.message });
  }

  // Test 13: detectLocalSource finds local upgrades
  try {
    const { detectLocalSource } = await import('./upgrade-manager.js');
    const localSource = await detectLocalSource();
    // May be null if no local source available - that's valid
    assert(localSource === null || typeof localSource === 'string', 'detectLocalSource should return string or null');
    results.push({ test: 'detectLocalSource detection', passed: true });
  } catch (error) {
    results.push({ test: 'detectLocalSource detection', passed: false, error: error.message });
  }

  // Test 14: previewUpgrade returns correct structure
  try {
    const { previewUpgrade } = await import('./upgrade-manager.js');
    const preview = await previewUpgrade();
    assert(typeof preview === 'object', 'previewUpgrade should return object');
    assert(typeof preview.hasUpdate === 'boolean', 'hasUpdate should be boolean');
    assert(typeof preview.current === 'string', 'current should be string');
    results.push({ test: 'previewUpgrade structure', passed: true });
  } catch (error) {
    results.push({ test: 'previewUpgrade structure', passed: false, error: error.message });
  }

  // Test 15: trigger-detector detects upgrade trigger
  try {
    const { detectTrigger } = await import('./trigger-detector.js');
    const trigger = await detectTrigger('upgrade GSD');
    assert(trigger.type === 'upgrade', 'Should detect upgrade trigger');
    assert(trigger.matched === true, 'Should match trigger phrase');
    results.push({ test: 'trigger-detector upgrade trigger', passed: true });
  } catch (error) {
    results.push({ test: 'trigger-detector upgrade trigger', passed: false, error: error.message });
  }

  return results;
}
```

Update test suite list and final summary:
- Add to test suite list: `{ name: 'Test Suite 17: Upgrade System (Phase 11)', fn: testSuite17_UpgradeSystem }`
- Update final summary to include Test Suite 17 in total count

Expected: 15 tests for dual-mode upgrade system modules and integration.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
npm test
```

Expected: All tests pass (95 existing + 15 new = 110 tests total).
  </verify>
  <done>Test Suite 17 added with 15 tests, dual-mode support tested, all tests pass, integration-test.js updated</done>
</task>

<task type="auto">
  <name>Task 2: Create CHANGELOG.md with upgrade documentation</name>
  <files>gsd/CHANGELOG.md</files>
  <action>
Create gsd/CHANGELOG.md with upgrade process documentation and version history.

**CHANGELOG.md content:**

```markdown
# Changelog

All notable changes to GSD for Tabnine will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Upgrade system for seamless GSD updates (Phase 11)
- Version detection and update notification
- Backup and rollback capabilities
- File merge strategies preserving user customizations
- Migration runner for breaking changes
- "upgrade GSD" trigger phrase

## [1.0.0] - 2026-01-22

Initial release of GSD for Tabnine.

### Added
- Foundation & Templates (Phase 1)
- Core Infrastructure (Phase 2)
- Workflow Orchestration (Phase 3)
- Advanced Features (Phase 4)
- Discussion & Context System (Phase 6)
- Enhanced Research Infrastructure (Phase 7)
- Verification & Quality System (Phase 8)
- Improved Initialization Terminology (Phase 9)
- Path Handling Bug Fixes (Phase 10)

---

## Upgrading

### Automatic Upgrade (npm)

If npm registry is available:

1. **Run upgrade:**
   Say "upgrade GSD" to Tabnine agent, or run manually:
   ```bash
   cd gsd
   node scripts/upgrade-manager.js
   ```

2. **Auto-detection:**
   - System checks npm registry connectivity
   - Downloads latest version automatically
   - Shows preview before applying
   - Requires confirmation

3. **The upgrade will:**
   - Create backup in `.gsd-backups/backup-<timestamp>/`
   - Preserve your `.gsd-config.json` customizations
   - Update templates, guidelines, scripts, and package.json
   - Run any migrations for breaking changes
   - Validate the upgrade

### Manual Upgrade (Local)

If npm unavailable or behind firewall:

1. **Download new version:**
   ```bash
   # From GitHub releases
   wget https://github.com/you/gsd-for-tabnine/archive/v1.2.0.tar.gz
   tar -xzf v1.2.0.tar.gz -C ../gsd-upgrade
   ```

2. **Run upgrade:**
   ```bash
   cd gsd
   node scripts/upgrade-manager.js
   ```
   The system will auto-detect the local source in `../gsd-upgrade/`

3. **Or specify path explicitly:**
   ```bash
   node scripts/upgrade-manager.js --source=local --path=../gsd-for-tabnine-1.2.0/gsd
   ```

### Dry-Run Preview

Test upgrade without applying changes:
```bash
node scripts/upgrade-manager.js --dry-run
```

Shows:
- Upgrade source (npm or local)
- Current and target versions
- Files to update/preserve/merge
- Migrations to run

4. **Verify everything works:**
   Test your workflows. If issues occur:
   ```bash
   # Rollback to backup
   node scripts/backup-manager.js --restore .gsd-backups/backup-<timestamp>/
   ```

5. **Clean up:**
   After verifying, remove backup:
   ```bash
   rm -rf .gsd-backups/backup-<timestamp>/
   ```

### Migration Notes

#### 1.0.0 → 1.1.0 (Example - Future)
- No breaking changes
- New features: X, Y, Z
- Config changes: None

#### 1.1.0 → 2.0.0 (Example - Future)
- **BREAKING CHANGE:** Config format updated
- Migration script automatically updates `.gsd-config.json`
- New workflow: research-phase.md

### Versioning Policy

- **Major version (X.0.0):** Breaking changes requiring migration
- **Minor version (0.X.0):** New features, backward compatible
- **Patch version (0.0.X):** Bug fixes, no new features

[Unreleased]: https://github.com/yourusername/gsd-for-tabnine/compare/v1.0.0...HEAD
[1.0.0]: https://github.com/yourusername/gsd-for-tabnine/releases/tag/v1.0.0
```

This follows Keep a Changelog format and provides clear upgrade instructions.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify CHANGELOG exists
cat CHANGELOG.md | head -30

# Verify format (Keep a Changelog)
grep -E "\[Unreleased\]|\[1\.0\.0\]|## Upgrading" CHANGELOG.md
```

Expected: CHANGELOG.md exists, contains Upgrading section, follows Keep a Changelog format.
  </verify>
  <done>CHANGELOG.md created with upgrade documentation, version history, and migration notes</done>
</task>

<task type="auto">
  <name>Task 3: Update README.md with upgrade instructions</name>
  <files>gsd/README.md</files>
  <action>
Update gsd/README.md to include upgrade instructions section.

Add after the "Quick Start" section and before "How It Works":

```markdown
## Upgrading

GSD includes a built-in upgrade system to keep your installation current.

### Check for Updates

Say to Tabnine: **"upgrade GSD"**

Or manually:
```bash
cd gsd
node scripts/upgrade-manager.js --dry-run
```

### Upgrade Sources

GSD automatically detects the best upgrade source:

**Automatic (npm registry):**
- Checks npm registry for latest version
- Downloads and applies automatically
- Requires internet connection

**Fallback (local):**
- If npm unavailable, looks for local upgrade in:
  - `../gsd-upgrade/`
  - `../gsd-latest/`
  - `../gsd-for-tabnine/`
- Download manually if needed:
  ```bash
  # Download from GitHub
  wget https://github.com/you/gsd-for-tabnine/archive/v1.2.0.tar.gz
  tar -xzf v1.2.0.tar.gz -C ../gsd-upgrade
  ```

**Manual source:**
```bash
node scripts/upgrade-manager.js --source=local --path=/custom/path
```

### Preview Changes

The dry-run shows:
- Current and latest versions
- Upgrade source (npm or local)
- Files that will be updated
- Your customizations that will be preserved
- Migrations that will run

### Apply Upgrade

Confirm the upgrade via Tabnine prompt, or run:
```bash
node scripts/upgrade-manager.js
```

**Safety features:**
- ✅ Auto-detects npm or local source
- ✅ Automatic backup before upgrade
- ✅ Preserves your `.gsd-config.json` customizations
- ✅ Rollback on failure
- ✅ Validation after upgrade
- ✅ Works offline with local upgrades

### Rollback

If something goes wrong:
```bash
node scripts/backup-manager.js --restore .gsd-backups/backup-<timestamp>/
```

See [CHANGELOG.md](CHANGELOG.md) for detailed upgrade notes and migration guides.

---
```

This provides clear, actionable upgrade instructions without overwhelming users.
  </action>
  <verify>
```bash
cd "C:\Projects\GSDForTabnine\gsd"
# Verify section added
grep -A 10 "## Upgrading" README.md

# Verify links
grep "CHANGELOG.md" README.md
```

Expected: README.md contains Upgrading section with clear instructions and CHANGELOG link.
  </verify>
  <done>README.md updated with upgrade section, safety features documented, CHANGELOG link added</done>
</task>

</tasks>

<verification>
**Testing:**
- Test Suite 17 added with 12 tests
- All upgrade modules validated (version-checker, backup-manager, file-merger, migration-runner, upgrade-manager)
- Backup creation and validation tested
- File strategies tested
- Trigger detection tested
- All 107 tests pass (95 existing + 12 new)

**Documentation:**
- CHANGELOG.md created following Keep a Changelog format
- Upgrade process documented step-by-step
- Versioning policy explained
- Migration notes template provided
- README.md updated with upgrade section
- Safety features highlighted
- Rollback instructions provided

**Integration:**
- Upgrade system integrated with existing test suite
- Documentation linked (README → CHANGELOG)
- User-facing and developer-facing docs complete
</verification>

<success_criteria>
**Plan complete when:**
1. Test Suite 17 added to integration-test.js
2. 15 dual-mode upgrade system tests implemented
3. Tests cover npm mode, local mode, and auto-detection
4. All tests pass (110 total: 95 existing + 15 new)
5. CHANGELOG.md created with upgrade documentation
6. Version history documented
7. Migration notes template provided
8. README.md updated with upgrade section
9. Both npm and local upgrade workflows documented
10. Safety features documented
11. Rollback instructions provided
12. Documentation follows industry standards (Keep a Changelog, semver)
</success_criteria>

<output>
After completion, create `.planning/phases/11-upgrade-system/11-05-SUMMARY.md`
</output>
